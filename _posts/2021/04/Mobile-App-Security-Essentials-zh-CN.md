---
title: "移动应用安全要点：保护用户口袋中的数据"
date: 2021-04-04
lang: zh-CN
categories: Cybersecurity
tags: [Architecture, Security, Best Practices]
excerpt: "移动设备存储敏感数据并连接到关键服务。学习基本的安全架构原则，保护用户免受数据泄露、逆向工程和运行时攻击。"
---

移动应用处理越来越敏感的数据——银行凭证、健康记录、私人通信和商业文档。与在您控制的服务器上执行安全逻辑的Web应用不同，移动应用运行在您无法控制的设备上，在您无法信任的环境中，被可能成为复杂攻击者目标的用户访问。这一根本差异需要不同的安全方法。

移动应用安全不仅仅是防止未经授权的访问。它涉及保护设备上的静态数据、保护通过不可信网络传输的数据、防止应用逻辑的逆向工程，以及防御运行时操纵。每个挑战都需要特定的架构决策和仔细规划。

本文涵盖iOS和Android平台的基本移动安全架构。我们将研究安全数据存储策略、网络通信保护、代码混淆方法、运行时安全模式和身份验证设计。通过架构原则和实际场景，我们将建立对移动安全基础的全面理解。

## 安全数据存储架构

移动设备在敌对环境中存储数据。用户丢失手机、恶意软件感染设备、攻击者获得物理访问权限。即使设备本身受到威胁，您的应用也必须保护敏感数据。

### 存储层次结构

移动平台提供多种具有不同安全特性的存储机制：

!!!anote "📦 存储选项和安全级别"
    **iOS存储机制**
    - UserDefaults：未加密，仅适用于非敏感偏好设置
    - Keychain：硬件支持的加密，最适合凭证和密钥
    - 文件系统：使用数据保护API加密
    - Core Data：使用数据保护时加密
    
    **Android存储机制**
    - SharedPreferences：默认未加密，避免用于敏感数据
    - Keystore：硬件支持的加密，最适合加密密钥
    - 内部存储：应用私有但默认未加密
    - EncryptedSharedPreferences：加密偏好设置（Android 6.0+）
    - Room数据库配合SQLCipher：加密数据库存储

关键原则：无论多么方便，永远不要在未加密的存储中存储敏感数据。

### 平台提供的安全性：正确的选择

iOS Keychain和Android Keystore提供硬件支持的加密，远优于您可能实现的任何应用级加密。这些系统利用安全飞地和可信执行环境，将加密密钥存储在甚至操作系统都无法访问的硬件中。

!!!tip "🔑 为什么平台API更胜一筹"
    **硬件支持的安全性**
    - 密钥存储在安全硬件中
    - 在可信环境中执行加密操作
    - 防止物理攻击
    - 操作系统级访问控制
    
    **正确的密钥管理**
    - 密钥永不暴露给应用
    - 自动密钥轮换支持
    - 安全密钥派生
    - 可用生物识别绑定
    
    **经过实战检验的实现**
    - 经过安全专家审查
    - 定期安全更新
    - 符合标准
    - 跨设备广泛测试

自定义加密实现会引入漏洞。硬编码密钥、弱算法、不当的初始化向量和有缺陷的密钥派生是常见错误。平台API消除了这些风险。

### 可访问性和备份考虑

数据可访问性决定了加密数据何时可用以及是否备份到云服务。这些决策在安全性和可用性之间取得平衡。

在iOS上，Keychain可访问性选项控制数据何时可访问以及是否包含在备份中。最安全的选项——仅在解锁时可访问且永不备份——提供最大保护，但可能限制后台功能。限制较少的选项启用后台任务，但如果设备受到威胁，则会增加暴露风险。

Android的Keystore提供类似的控制。密钥可以要求用户身份验证、绑定到特定时间段或限制为特定的加密操作。EncryptedSharedPreferences自动处理加密，但需要仔细配置以从备份中排除敏感数据。

!!!warning "⚠️ 常见存储错误"
    **永不以明文存储**
    - 不要使用UserDefaults/SharedPreferences存储密码
    - 不要在代码或配置文件中存储API密钥
    - 不要将敏感数据记录到控制台
    
    **避免自定义加密**
    - 不要实现自己的加密算法
    - 不要使用硬编码的加密密钥
    - 不要使用弱算法（DES、MD5、SHA1）
    
    **备份考虑**
    - 敏感数据可能备份到云端
    - 在iOS上使用"ThisDeviceOnly"可访问性
    - 从Android备份中排除敏感文件

## 网络安全架构

移动应用通过不可信网络通信——公共WiFi、蜂窝网络、受损路由器。每个网络请求都是拦截或操纵的机会。

### 超越HTTPS：纵深防御

仅使用HTTPS是不够的。适当的网络安全需要多层：TLS配置、证书验证、证书固定和请求签名。

TLS配置决定您的应用接受哪些协议版本和密码套件。支持过时的协议（如TLS 1.0）或弱密码套件会使用户暴露于已知攻击。现代应用应强制使用TLS 1.2或更高版本，并使用强密码套件。

证书验证确保您与合法服务器通信。iOS和Android提供的默认验证通常足够，但应用可以实现额外检查。证书固定——验证特定证书或公钥——提供针对受损证书颁发机构的保护，但引入了操作复杂性。

请求签名添加加密证明，证明请求未被篡改。即使通过HTTPS，请求签名也能防止某些类别的攻击并提供不可否认性。基于HMAC的签名使用共享密钥或使用公钥加密的非对称签名都可以工作，各有不同的权衡。

!!!error "🚫 网络安全错误"
    **禁用证书验证**
    - 永不在生产环境中禁用SSL验证
    - 不要信任所有证书
    - 不要忽略证书错误
    
    **允许明文流量**
    - 不要在生产应用中允许HTTP
    - 对所有连接强制使用HTTPS
    - 使用App Transport Security（iOS）/网络安全配置（Android）
    
    **弱TLS配置**
    - 不要支持TLS 1.0或1.1
    - 避免弱密码套件
    - 将最低TLS版本保持在1.2或更高

### 证书固定：来自实战的教训

证书固定承诺增强安全性，但引入了操作风险。配置错误的固定或过期证书可能使应用无法使用。[证书固定文章](/2021/03/Certificate-Pinning-Security-Trade-offs/)深入探讨了这些权衡，但关键教训是：在所有环境中彻底测试启用固定的情况。

在证书轮换期间，我们的测试团队在UAT中禁用了固定，因为"太难测试"。他们运行了完整的测试套件并报告成功——但固定被禁用了，所以他们没有验证任何关于生产行为的内容。只有启用固定的单独预发布环境才发现了问题：新证书使用了与我们固定逻辑不匹配的通配符通用名称。

!!!success "✅ 网络安全原则"
    **强制使用强TLS**
    - 最低TLS 1.2
    - 仅使用强密码套件
    - 使用平台安全配置
    
    **正确验证证书**
    - 使用平台验证作为基线
    - 仅在合理时添加固定
    - 在所有环境中测试固定
    
    **签名关键请求**
    - 防止篡改
    - 包含时间戳以防止重放
    - 使用恒定时间比较
    - 在服务器端验证

## 代码保护策略

移动应用分发给可能尝试逆向工程的用户。虽然完美的保护是不可能的，但您可以显著提高门槛。

### 混淆：减慢攻击者速度

代码混淆将可读代码转换为功能等效但难以理解的代码。类名变成单个字母，方法名变成无意义的字符串，控制流变得复杂。混淆不能防止逆向工程——有决心的攻击者会成功——但它增加了所需的时间和技能。

由于Java字节码的可读性，Android应用特别容易受到攻击。ProGuard和R8提供混淆、压缩和优化。正确配置后，它们会删除调试信息、重命名类和方法，并消除未使用的代码。

iOS应用编译为本机代码，本质上比Android的字节码更难逆向工程，但混淆仍然有帮助。字符串加密隐藏API端点和配置。控制流混淆使逻辑更难跟踪。符号剥离删除调试信息。

!!!tip "🛡️ 混淆策略"
    **要混淆的内容**
    - 业务逻辑和算法
    - API端点和参数
    - 内部类和方法名称
    - 敏感字符串常量
    
    **要保留的内容**
    - 公共API接口
    - 通过反射使用的类
    - 本机方法声明
    - 序列化类
    
    **测试要求**
    - 彻底测试发布版本
    - 验证崩溃报告可读
    - 检查基于反射的代码是否工作
    - 归档映射文件以进行反混淆

### 混淆的局限性

混淆不是安全性。它是减速带，不是墙。具有足够动机和技能的攻击者无论如何都会逆向工程您的应用。目标是使逆向工程足够昂贵，以至于攻击者追求更容易的目标，或者您在他们成功之前检测到攻击。

!!!warning "⚠️ 混淆局限性"
    **不是真正的安全性**
    - 混淆减慢攻击者速度，但不能阻止他们
    - 有决心的攻击者会逆向工程您的应用
    - 不要依赖混淆来实现关键安全性
    
    **纵深防御**
    - 将混淆与服务器端验证结合
    - 使用运行时完整性检查
    - 实施速率限制和异常检测
    - 监控可疑行为

关键安全决策应在您控制环境的服务器端进行。客户端验证是为了用户体验；服务器端验证是为了安全性。混淆保护知识产权并提高攻击者的门槛，但它不能取代适当的安全架构。

## UI安全：保护可见数据

屏幕上显示的敏感数据仍然容易受到截图、屏幕录制和应用切换器预览的影响。UI安全措施保护数据免受视觉捕获。

### 屏幕捕获防护

截图和屏幕录制可以捕获应用中显示的敏感信息。银行应用、医疗保健应用和具有私人内容的消息应用应防止敏感屏幕的屏幕捕获。

在iOS上，不直接支持防止截图——平台优先考虑用户控制。但是，您可以检测何时截取截图并做出适当响应，例如记录事件或警告用户。对于高度敏感的内容，考虑使用安全文本输入字段，这些字段会自动从截图中排除。

Android提供FLAG_SECURE来防止截图和屏幕录制。此标志将窗口标记为安全，防止其内容出现在截图、屏幕录制或非安全显示器中。将此标志应用于显示敏感信息的活动。

!!!anote "📸 屏幕捕获策略"
    **何时防止捕获**
    - 银行交易屏幕
    - 医疗记录和PHI
    - 私人消息和通信
    - 支付信息输入
    - 身份验证屏幕
    
    **何时允许捕获**
    - 公共信息屏幕
    - 用户拥有的用户生成内容
    - 设置和偏好
    - 帮助和文档
    
    **用户体验考虑**
    - 告知用户为何阻止捕获
    - 允许捕获非敏感屏幕
    - 考虑可访问性需求
    - 平衡安全性与可用性

### 应用切换器安全

当用户在应用之间切换时，移动操作系统会显示最近应用的预览。这些预览可能会向任何有物理访问设备权限的人暴露敏感信息。银行余额、私人消息、医疗数据——都在应用切换器中可见。

iOS和Android都会在应用移至后台时捕获快照。如果没有保护，这些快照会显示屏幕上的任何内容，可能会暴露敏感数据数小时或数天，直到应用重新打开或设备重启。

解决方案是在捕获快照之前遮盖敏感内容。当应用进入后台时显示空白屏幕、启动屏幕或通用占位符。当应用返回前台时，恢复实际内容。

!!!tip "🔒 应用切换器保护策略"
    **要隐藏的内容**
    - 账户余额和财务数据
    - 个人健康信息
    - 私人消息和通信
    - 个人身份信息
    - 身份验证屏幕
    
    **实现方法**
    - 显示空白/白色屏幕
    - 显示应用徽标或启动屏幕
    - 显示通用占位符内容
    - 模糊或像素化敏感区域
    
    **时机考虑**
    - 在后台时立即应用保护
    - 在前台时移除保护
    - 处理快速应用切换
    - 考虑动画过渡

保护必须在系统捕获快照之前激活。两个平台都提供生命周期回调，指示应用何时即将进入后台。通过在快照发生之前隐藏敏感内容来响应这些回调。

### 平衡安全性和用户体验

UI安全措施影响用户体验。防止截图会让试图出于合法目的保存信息的用户感到沮丧。空白的应用切换器预览使识别要返回的应用变得更加困难。关键是按比例应用这些保护。

高安全性屏幕——身份验证、交易、敏感数据——证明采用积极保护是合理的。一般导航、设置和公共信息屏幕不需要相同级别的保护。根据显示内容的敏感性有选择地应用UI安全措施。

!!!warning "⚠️ UI安全考虑"
    **不要过度保护**
    - 并非每个屏幕都需要捕获防护
    - 用户可能有合法的截图理由
    - 可访问性工具可能需要屏幕内容
    - 平衡安全性与可用性
    
    **适当保护**
    - 识别真正敏感的屏幕
    - 一致地应用保护
    - 在保护激活时告知用户
    - 在不同场景下测试
    
    **平台限制**
    - iOS不支持截图防护
    - Android FLAG_SECURE在已root设备上可以被绕过
    - 屏幕录制应用可能规避保护
    - 物理相机始终可以捕获屏幕

## 运行时安全架构

移动应用在您无法控制的环境中运行。适当地检测和响应受损设备。

### 检测受损环境

Android上的root检测和iOS上的越狱检测识别用户具有提升权限的设备。已root和已越狱的设备可以绕过应用安全控制、访问受保护的数据并操纵应用行为。

检测技术包括检查已知的root/越狱文件、测试应用是否可以在其沙箱外写入、检测root管理应用以及检查构建签名。没有检测是完美的——复杂的攻击者可以隐藏root/越狱状态——但基本检查可以捕获普通用户和自动化攻击。

调试器检测识别应用何时在调试器下运行，攻击者使用调试器来分析行为并绕过安全控制。检查调试器附加、测试特定调试器工件以及监控可疑的时序模式都有助于检测调试尝试。

!!!anote "🔍 检测响应策略"
    **优雅降级**
    - 在受损设备上禁用敏感功能
    - 向用户显示警告
    - 限制功能而不是完全阻止
    
    **静默监控**
    - 将检测事件记录到分析
    - 监控滥用模式
    - 使用服务器端风险评分
    
    **硬阻止**
    - 拒绝在已root/已越狱设备上运行
    - 仅适用于高安全性应用
    - 向用户提供清晰的解释

### 响应策略很重要

您如何响应检测到的威胁与检测本身同样重要。硬阻止——拒绝在已root或已越狱设备上运行——提供最大安全性，但会让合法的高级用户感到沮丧。优雅降级——禁用敏感功能同时允许基本功能——平衡安全性和可用性。静默监控——记录检测而不进行用户可见的更改——使基于风险的决策成为可能，而不会让误报影响用户。

适当的响应取决于您的威胁模型和用户群。银行应用可能证明硬阻止是合理的。社交媒体应用可能使用优雅降级。企业应用可能实施静默监控和服务器端风险评分。

## 身份验证架构

身份验证确定谁可以访问您的应用以及他们可以做什么。移动身份验证必须平衡安全性和可用性。

### 生物识别身份验证：安全性与可用性的结合

生物识别身份验证——指纹、面部识别、虹膜扫描——提供强大的安全性和出色的用户体验。用户无需记住密码即可快速进行身份验证。生物识别数据永不离开设备，完全在安全硬件中处理。

平台生物识别API处理生物识别身份验证的复杂性。iOS Face ID和Touch ID、Android BiometricPrompt——这些API在设备之间提供一致的接口，处理回退到设备凭证，并在安全飞地中保护生物识别数据。

生物识别身份验证应该补充而不是取代传统身份验证。初始登录需要用户名和密码（或等效凭证）。生物识别技术支持后续会话的快速重新身份验证。这种方法提供安全性——受损的生物识别技术不会授予永久访问权限——同时保持可用性。

!!!tip "🔐 身份验证最佳实践"
    **生物识别身份验证**
    - 专门使用平台API
    - 永不直接处理生物识别数据
    - 提供回退到设备凭证
    - 初始登录需要传统身份验证
    
    **令牌管理**
    - 在Keychain/Keystore中存储令牌
    - 实施令牌刷新
    - 注销时清除令牌
    - 使用短期访问令牌
    
    **会话管理**
    - 实施适当的超时
    - 对敏感操作重新身份验证
    - 在后台清除会话数据
    - 优雅地处理会话过期

### 多因素身份验证

多因素身份验证（MFA）需要多种形式的验证：您知道的东西（密码）、您拥有的东西（设备、安全密钥）、您是谁（生物识别）。MFA通过要求攻击者破坏多个因素来显著提高安全性。

移动应用非常适合MFA。设备本身充当占有因素。推送通知支持轻松批准身份验证尝试。基于时间的一次性密码（TOTP）提供额外验证。生物识别技术添加第三个因素。

实施MFA需要仔细的UX设计。过多的摩擦会促使用户禁用安全功能或放弃应用。渐进式身份验证——仅对敏感操作要求额外因素——平衡安全性和可用性。

## 安全测试策略

测试安全实现与实现它们同样重要。在理想条件下工作但在边缘情况下失败的安全性提供了虚假的信心。

### 在真实设备上测试

模拟器和仿真器不能准确代表生产环境。安全功能在真实硬件上的行为不同。安全飞地、生物识别传感器和硬件支持的密钥库仅存在于物理设备上。在多个制造商和操作系统版本的真实设备上进行测试。

测试失败场景。当Keychain访问失败时会发生什么？当网络请求被拦截时？当设备已root时？当生物识别身份验证不可用时？安全实现必须优雅地处理失败，而不会暴露数据或崩溃。

### 永不在测试中禁用安全性

在非生产环境中禁用安全功能的诱惑很强，但它会破坏测试。如果在UAT中禁用证书固定，因为"太难测试"，UAT就不会验证任何关于固定行为的内容。第一次真正的测试变成了生产环境，失败会影响用户。

!!!error "🚫 适得其反的测试捷径"
    **为什么团队在UAT中禁用安全性**
    - "证书固定太难测试"
    - "我们在UAT中使用自签名证书"
    - "固定失败在测试中太常见"
    - "它减慢了我们的测试周期"
    
    **为什么这会失败**
    - 测试应验证生产行为
    - 如果难以测试，就难以操作
    - 常见失败表明真正的问题
    - 缓慢的测试优于生产中断

在所有环境中维护安全功能。是的，在UAT中管理证书更难。是的，它需要团队之间的协调。是的，它会减慢某些测试场景。但它可以防止生产灾难。在测试环境中维护安全性的操作负担远小于影响数千或数百万用户的生产中断的成本。

## 威胁建模和风险评估

在实施安全措施之前，了解您要防御的威胁以及保护是否证明复杂性是合理的。

### 并非每个应用都需要每个安全功能

天气应用与银行应用有不同的安全要求。天气应用可能跳过root检测和代码混淆，专注于基本的HTTPS和用户偏好的安全存储。银行应用证明全面安全是合理的：硬件支持的存储、证书固定、代码混淆、root检测和生物识别身份验证。

将安全投资与您的风险概况相匹配。考虑：

- 您的应用处理什么敏感数据？
- 如果该数据被泄露，影响是什么？
- 谁可能攻击您的应用，为什么？
- 潜在攻击者拥有什么资源？
- 实施和维护安全措施的成本是多少？
- 对用户体验的影响是什么？

!!!anote "✅ 基于风险的安全决策"
    **高安全性应用**
    - 银行和金融服务
    - 包含PHI的医疗保健
    - 政府和国防
    - 具有敏感数据的企业
    
    **中等安全性应用**
    - 具有私人消息的社交媒体
    - 具有支付数据的电子商务
    - 具有用户数据的生产力应用
    
    **低安全性应用**
    - 公共信息应用
    - 没有购买的游戏
    - 没有用户数据的实用程序

### 纵深防御

没有单一的安全措施是足够的。纵深防御——多层保护——确保如果一层失败，其他层提供保护。安全存储保护静态数据。TLS保护传输中的数据。混淆减慢逆向工程。运行时检测识别受损环境。服务器端验证捕获客户端绕过。

每一层都解决不同的威胁并具有不同的优势。结合起来，它们创造的安全态势大于各部分的总和。

## 运营安全考虑

安全性不会在部署时结束。持续运营决定安全措施是否保持有效。

### 监控和事件响应

监控安全事件：root检测触发、证书验证失败、可疑的身份验证模式、异常的API使用。这些事件表明潜在的攻击或受损设备。聚合监控数据以识别单个事件可能遗漏的模式。

准备好事件响应程序。当您检测到受损设备时会发生什么？当证书需要紧急轮换时？当发现漏洞时？记录的程序使事件发生时能够快速响应。

### 更新和修补

安全漏洞不断被发现。平台安全API不断发展。攻击技术不断进步。定期更新解决漏洞、采用新的安全功能并响应新兴威胁。

实施机制以鼓励或要求更新。关于关键安全更新的推送通知。对具有严重漏洞的应用强制执行最低版本。平衡安全需求与用户体验——强制更新会让用户感到沮丧，但对于关键安全问题可能是必要的。

### 密钥轮换和证书管理

加密密钥和证书的生命周期有限。在过期之前计划轮换。在非生产环境中测试轮换程序。为受损的密钥或证书准备紧急程序。

证书固定需要特别仔细的管理。固定多个证书或公钥以支持轮换而无需应用更新。监控证书过期日期。在部署之前测试新证书。准备好回滚程序。

## 结论

移动应用安全需要全面的架构来应对多个威胁向量。安全数据存储保护静态信息，使用平台提供的机制（如iOS Keychain和Android Keystore）而不是自定义加密。网络安全超越HTTPS，包括适当的TLS配置、证书验证和请求签名。通过混淆进行代码保护提高了逆向工程的门槛，尽管它不能阻止有决心的攻击者。运行时安全检测受损环境，允许应用适当地响应已root设备和调试器。

移动安全的根本挑战是应用在您无法控制的敌对环境中运行。用户可能丢失设备、安装恶意软件或成为复杂攻击者的目标。您的安全模型必须假设设备本身受到威胁，并实施纵深防御——多层保护协同工作以最小化风险。

平台提供的安全机制几乎总是优于自定义实现。iOS Keychain和Android Keystore提供硬件支持的加密，远比您可能实现的任何应用级加密更安全。网络安全配置和App Transport Security以声明方式强制执行TLS最佳实践，减少实现错误的风险。生物识别身份验证API提供安全、用户友好的身份验证，而无需您处理敏感的生物识别数据。

安全性和可用性之间的平衡在移动应用中至关重要。过于激进的安全措施会让用户感到沮丧，并促使他们转向不太安全的替代方案。阻止所有已root设备的root检测可能会阻止合法的高级用户使用您的应用。过于频繁地要求重新身份验证的生物识别身份验证会变得令人讨厌。目标是比例安全——将安全措施与数据的敏感性和操作的风险相匹配。

测试安全实现与实现它们同样重要。在真实设备上测试，而不仅仅是模拟器。使用各种操作系统版本进行测试，因为安全API会发展。测试失败场景——当Keychain访问失败时会发生什么，当网络请求被拦截时，当设备已root时？在理想条件下完美工作但在边缘情况下灾难性失败的安全性提供了虚假的信心。永远不要因为"太难"而在测试环境中禁用安全功能——这种困难是您的早期警告系统。

移动安全不是一次性实现，而是一个持续的过程。新的漏洞被发现，平台不断发展，攻击技术不断进步。随时了解平台安全更新，监控您使用的库的安全公告，并定期审查您的安全实现。移动安全格局变化迅速，昨天的最佳实践可能是今天的漏洞。

在实施任何安全措施之前，了解您要防御的威胁以及保护是否证明复杂性是合理的。并非每个应用都需要root检测或代码混淆。天气应用与银行应用有不同的安全要求。将您的安全投资与您的实际风险概况相匹配，并在添加高级保护之前专注于基础——安全存储、适当的TLS和强身份验证。

移动应用安全具有挑战性，因为您要在多个层面上防御威胁——网络攻击、设备威胁、逆向工程和运行时操纵。但是，通过利用平台安全功能、实施纵深防御以及通过测试和更新保持警惕，您可以构建即使在敌对环境中也能保护用户数据的移动应用。设备可能在用户的口袋里，但安全责任仍然是您的。
