---
title: "左移之後的右移：完整的 DevOps 全景"
date: 2022-11-04
tags: [DevOps, Testing, Monitoring]
categories: [Development]
lang: zh-TW
excerpt: "左移將測試提前到開發早期。但接下來呢？探索透過生產監控、混沌工程和持續學習來完善 DevOps 循環的右移實踐。"
thumbnail: /assets/devops/thumbnail.png
---

多年來，DevOps 世界一直在熱議「左移」——在開發週期的早期階段引入測試、安全和品質檢查。我們已經實現了單元測試自動化，將安全掃描整合到 CI/CD 流水線中，並在 bug 到達生產環境之前捕獲它們。這是革命性的。

但問題是：左移只是故事的一半。

當我們忙於完善預生產流程時，生產環境變得越來越複雜。微服務、分散式系統和雲原生架構創造了在開發中無法預測的故障模式。無論進行多少預生產測試，都無法模擬真實使用者、真實資料和大規模真實基礎設施的混亂。

這就是「右移」的用武之地——將 DevOps 實踐擴展到生產環境及其之後。這不是要放棄左移原則；而是透過將生產環境視為學習環境的實踐來完成循環。

## 理解左移：快速回顧

在探索右移之前，讓我們先釐清左移實現了什麼。傳統的軟體開發生命週期是這樣的：

{% mermaid %}
graph LR
    A([📝 需求]) --> B([💻 開發])
    B --> C([🧪 測試])
    C --> D([🚀 部署])
    D --> E([⚙️ 維運])
    style C fill:#fff3e0,stroke:#f57c00,stroke-width:2px
    style E fill:#ffebee,stroke:#c62828,stroke-width:2px
{% endmermaid %}

測試發生得很晚，在開發「完成」之後。在這個階段發現 bug 的成本很高——程式碼必須返回給已經轉向其他專案的開發人員。回饋循環緩慢且成本高昂。

左移將品質實踐提前：

{% mermaid %}
graph LR
    A([📝 需求<br/>+ 測試計畫]) --> B([💻 開發<br/>+ 單元測試])
    B --> C([🧪 整合測試<br/>+ 安全掃描])
    C --> D([🚀 部署])
    D --> E([⚙️ 維運])
    style A fill:#e3f2fd,stroke:#1976d2,stroke-width:2px
    style B fill:#e8f5e9,stroke:#388e3c,stroke-width:2px
    style C fill:#fff3e0,stroke:#f57c00,stroke-width:2px
{% endmermaid %}

**關鍵左移實踐：**
- **測試驅動開發（TDD）**：在編寫程式碼之前編寫測試
- **持續整���**：每次提交時自動化測試
- **靜態程式碼分析**：在不執行程式碼的情況下捕獲問題
- **安全掃描**：儘早發現漏洞
- **基礎設施即程式碼**：測試基礎設施配置

這些實踐顯著提高了軟體品質並降低了成本。但它們有一個共同的局限性：它們都發生在生產環境之前。

## 右移哲學

右移認識到一個基本事實：生產環境是不同的。無論你在開發中測試得多麼徹底，生產環境都會給你驚喜。使用者的行為不可預測。基礎設施以意想不到的方式失敗。負載模式創造了你從未預料到的瓶頸。

右移不是將生產環境視為應該「正常運作」的黑盒，而是將生產環境視為學習環境。它將 DevOps 實踐擴展到部署之外：

{% mermaid %}
graph LR
    A([📝 需求]) --> B([💻 開發])
    B --> C([🧪 測試])
    C --> D([🚀 部署])
    D --> E([⚙️ 維運<br/>+ 監控])
    E --> F([📊 分析<br/>+ 學習])
    F -.回饋.-> A
    style E fill:#e0f2f1,stroke:#00796b,stroke-width:2px
    style F fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px
{% endmermaid %}

**核心右移原則：**

**生產環境是測試環境**：接受某些問題只會在生產環境中出現。設計系統以優雅地偵測和處理它們。

**可觀測性優於監控**：不僅僅是收集指標——理解系統行為。提出你的系統可以回答的問題。

**快速失敗，更快學習**：擁抱受控的失敗以建立韌性。從生產事故中學習以改進整個系統。

**持續回饋**：使用生產資料為開發決策提供資訊。在維運和開發之間形成閉環。

!!!tip "💡 左移 vs 右移"
    **左移**：在生產環境之前預防問題
    **右移**：在生產環境中偵測、回應和學習問題
    
    兩者都是必不可少的。左移減少了到達生產環境的問題數量。右移確保你能處理不可避免會出現的問題。

## 關鍵右移實踐

讓我們探討使右移有效的實踐。這些不是理論概念——它們是大規模執行系統的組織使用的經過實戰檢驗的方法。

### 1. 生產監控和可觀測性

傳統監控問「系統是否正常運作？」可觀測性問「系統為什麼會這樣運作？」

**監控**追蹤預定義的指標：CPU 使用率、記憶體消耗、請求速率、錯誤計數。你知道要測量什麼，因為你以前見過這些問題。

**可觀測性**讓你可以對系統行為提出任意問題：「為什麼這個特定使用者的請求花了 5 秒？」「下午 2 點到 3 點之間發生了什麼變化導致延遲激增？」你不需要提前預測問題。

{% mermaid %}
graph TB
    A([🌐 生產系統]) --> B([📊 指標<br/>CPU、記憶體、請求])
    A --> C([📝 日誌<br/>應用程式事件])
    A --> D([🔍 追蹤<br/>請求流])
    B --> E([🎯 可觀測性平台])
    C --> E
    D --> E
    E --> F([❓ 提出問題<br/>理解行為])
    style E fill:#e3f2fd,stroke:#1976d2,stroke-width:2px
    style F fill:#e8f5e9,stroke:#388e3c,stroke-width:2px
{% endmermaid %}

**可觀測性的三大支柱：**

**指標**：隨時間變化的數值測量（請求速率、錯誤率、延遲百分位數）。這些提供高層次的健康指標。

**日誌**：帶有上下文的離散事件（使用者登入、支付處理、錯誤發生）。這些提供有關特定事件的詳細資訊。

**追蹤**：透過分散式系統的請求流（單個使用者請求如何在微服務中傳播）。這些揭示依賴關係和瓶頸。

!!!example "🎬 真實場景"
    你的監控顯示錯誤率在下午 2:15 增加。這是監控。
    
    有了可觀測性，你可以：
    1. 過濾下午 2:15 之後失敗的請求追蹤
    2. 發現它們都呼叫了一個特定的微服務
    3. 檢查該服務的日誌，發現下午 2:14 發生了部署
    4. 識別引入 bug 的確切程式碼變更
    
    所有這些都在幾分鐘內完成，而不是幾小時。

**實施可觀測性：**

- **結構化日誌**：使用具有可搜尋欄位的一致日誌格式
- **分散式追蹤**：檢測程式碼以追蹤跨服務的請求
- **自訂指標**：追蹤特定於業務的指標，而不僅僅是基礎設施
- **關聯 ID**：跨系統連結相關事件
- **儀表板**：即時視覺化系統行為

### 2. 特性開關和漸進式交付

特性開關將部署與發布解耦。你可以將程式碼部署到生產環境而不向使用者公開，然後逐步為特定受眾啟用功能。

**特性開關的運作原理：**

```javascript
if (featureFlags.isEnabled('new-checkout-flow', user)) {
    // 新程式碼路徑
    return newCheckoutExperience(user);
} else {
    // 現有程式碼路徑
    return currentCheckoutExperience(user);
}
```

這個簡單的模式支援強大的部署策略：

**金絲雀發布**：為 1% 的使用者啟用功能，監控問題，逐步增加到 100%。

**A/B 測試**：向不同的使用者群組顯示不同的版本，測量哪個表現更好。

**環形部署**：首先向內部使用者推出，然後是測試使用者，最後是正式發布。

**終止開關**：無需重新部署即可立即停用有問題的功能。

{% mermaid %}
graph TB
    A([🚀 部署到生產環境]) --> B{特性開關}
    B -->|1% 使用者| C([👥 金絲雀組])
    B -->|99% 使用者| D([👥 現有體驗])
    C --> E{監控指標}
    E -->|成功| F([📈 增加到 10%])
    E -->|問題| G([🔴 停用開關])
    F --> H([繼續逐步推出])
    style E fill:#fff3e0,stroke:#f57c00,stroke-width:2px
    style G fill:#ffebee,stroke:#c62828,stroke-width:2px
    style H fill:#e8f5e9,stroke:#388e3c,stroke-width:2px
{% endmermaid %}

**好處：**

- **降低風險**：問題只影響一小部分使用者
- **快速回滾**：無需重新部署即可立即停用功能
- **資料驅動決策**：在完全推出之前測量真實使用者行為
- **解耦發布**：準備好時部署，有信心時發布

!!!warning "⚠️ 特性開關衛生"
    特性開關很強大，但可能成為技術債務。建立實踐：
    
    - 完全推出後刪除開關（不要累積死開關）
    - 記錄開關的目的和所有者
    - 為臨時開關設定過期日期
    - 定期監控開關使用情況並清理未使用的開關

### 3. 混沌工程

混沌工程故意在生產系統中引入故障，以驗證它們能夠承受動盪的條件。這聽起來違反直覺，但它基於一個簡單的前提：如果你將會有故障（而且你會），最好在你的條件下發生。

**混沌工程流程：**

1. **定義穩定狀態**：建立指示正常系統行為的指標（例如，99.9% 的請求在 200 毫秒內成功）

2. **假設**：預測當某些東西失敗時系統應該如何表現（例如，「如果支付服務當機，使用者應該看到友善的錯誤訊息，訂單應該排隊重試」）

3. **引入混沌**：在生產環境中故意造成故障（例如，終止支付服務實例）

4. **觀察**：監控系統是否保持穩定狀態

5. **學習和改進**：如果系統沒有按預期表現，修復問題並重複

{% mermaid %}
graph LR
    A([📊 定義<br/>穩定狀態]) --> B([🤔 假設<br/>行為])
    B --> C([💥 引入<br/>混沌])
    C --> D([👀 觀察<br/>結果])
    D --> E{穩定狀態<br/>保持？}
    E -->|是| F([✅ 信心<br/>增加])
    E -->|否| G([🔧 修復問題])
    G --> A
    style C fill:#ffebee,stroke:#c62828,stroke-width:2px
    style F fill:#e8f5e9,stroke:#388e3c,stroke-width:2px
    style G fill:#fff3e0,stroke:#f57c00,stroke-width:2px
{% endmermaid %}

**常見混沌實驗：**

**網路故障：**
- 在服務之間引入延遲
- 隨機丟棄封包
- 模擬網路分區

**資源耗盡：**
- 填滿磁碟空間
- 消耗所有可用記憶體
- 最大化 CPU 使用率

**服務故障：**
- 終止隨機實例
- 崩潰特定服務
- 模擬依賴故障

**基於時間的問題：**
- 引入時鐘偏移
- 模擬時區問題
- 測試閏秒處理

!!!anote "🎯 從小處開始"
    不要透過隨機終止生產伺服器來開始混沌工程。從以下開始：
    
    1. **非生產環境**：首先在預發布環境中練習
    2. **小爆炸半徑**：只影響一部分流量
    3. **工作時間**：在團隊可用時執行實驗
    4. **逐步升級**：從小問題開始，隨著時間的推移增加嚴重性
    
    隨著信心的增長，擴大範圍並自動化實驗。

**混沌工程工具：**

- **Chaos Monkey**：隨機終止實例（Netflix 的原始工具）
- **Gremlin**：具有全面故障注入的商業平台
- **Chaos Mesh**：Kubernetes 原生混沌工程平台
- **AWS Fault Injection Simulator**：AWS 的託管混沌工程

### 4. 生產測試

有些測試只在生產環境中有意義。這些不是為了發現 bug——而是為了驗證真實系統在真實條件下是否正確執行。

**合成監控**：針對生產環境持續執行的自動化測試，模擬使用者旅程：

```javascript
// 每 5 分鐘執行一次的合成測試
async function checkoutFlow() {
    // 1. 瀏覽產品
    await navigateTo('/products');
    
    // 2. 新增商品到購物車
    await addToCart('product-123');
    
    // 3. 進入結帳
    await checkout();
    
    // 4. 驗證訂單確認
    assert(orderConfirmed());
}
```

這些測試在真實使用者遇到問題之前向你發出警報。

**冒煙測試**：部署後快速驗證關鍵路徑是否運作：
- 使用者能登入嗎？
- 他們能檢視儀表板嗎？
- 他們能執行核心操作嗎？

**生產金絲雀**：接收真實流量但受到更密切監控的專用實例。如果金絲雀顯示問題，流量會在影響所有使用者之前被重新導向。

!!!example "🎬 生產測試實戰"
    一個電子商務網站每分鐘執行合成測試：
    - 瀏覽產品
    - 新增到購物車
    - 完成結帳
    
    凌晨 3:47，結帳測試失敗。支付閘道當機了。
    
    團隊立即收到警報並切換到備用支付提供商。當第一個真實客戶在早上 6:15 嘗試結帳時，一切都完美運作。
    
    如果沒有生產測試，直到客戶投訴才會發現問題。

### 5. 事故回應和學習

事故是不可避免的。重要的是你如何回應以及你學到了什麼。

**有效的事故回應：**

**偵測**：基於可觀測性資料的自動化警報快速捕獲問題。

**分類**：值班工程師評估嚴重性和影響，決定是否升級。

**溝通**：狀態頁面和內部頻道讓利益相關者了解情況。

**緩解**：修復眼前的問題（回滾、故障轉移、擴容）。

**解決**：永久解決根本原因。

**事後審查**：從發生的事情中學習，不歸咎於人。

{% mermaid %}
graph TB
    A([🚨 偵測到事故]) --> B([🔍 分類<br/>評估影響])
    B --> C([📢 溝通<br/>通知利益相關者])
    C --> D([🔧 緩解<br/>止血])
    D --> E([✅ 解決<br/>修復根本原因])
    E --> F([📝 事後審查<br/>學習和改進])
    F -.預防未來事故.-> G([🛡️ 實施保障措施])
    style A fill:#ffebee,stroke:#c62828,stroke-width:2px
    style D fill:#fff3e0,stroke:#f57c00,stroke-width:2px
    style F fill:#e3f2fd,stroke:#1976d2,stroke-width:2px
    style G fill:#e8f5e9,stroke:#388e3c,stroke-width:2px
{% endmermaid %}

**無責備事後分析：**

目標不是找出誰造成了事故——而是理解為什麼系統允許它發生。要問的問題：

- 發生了什麼？（事件時間軸）
- 為什麼會發生？（根本原因，而不僅僅是症狀）
- 我們如何偵測到它？（我們能更快地偵測到嗎？）
- 我們如何回應？（什麼有效？什麼無效？）
- 我們如何預防它？（具體的行動項目）

!!!tip "📚 從事故中學習"
    每個事故都是學習機會：
    
    - **徹底記錄**：未來的你會忘記細節
    - **廣泛分享**：其他團隊可以從你的經驗中學習
    - **追蹤行動項目**：確保改進真正發生
    - **測量 MTTR**：將平均恢復時間作為關鍵指標追蹤
    - **慶祝學習**：認可處理事故良好的團隊

## 平衡左移和右移

最有效的 DevOps 組織不會在左移和右移之間做選擇——他們兩者都擁抱。每個都解決軟體品質的不同方面：

{% mermaid %}
graph TB
    subgraph "左移：預防"
        A([單元測試])
        B([靜態分析])
        C([安全掃描])
        D([整合測試])
    end
    
    subgraph "部署"
        E([🚀 生產環境])
    end
    
    subgraph "右移：偵測和學習"
        F([監控])
        G([混沌工程])
        H([特性開關])
        I([事故回應])
    end
    
    A --> E
    B --> E
    C --> E
    D --> E
    E --> F
    E --> G
    E --> H
    E --> I
    I -.回饋.-> A
    style E fill:#e3f2fd,stroke:#1976d2,stroke-width:3px
{% endmermaid %}

**何時強調左移：**

- **已知風險**：你以前見過並可以測試的問題
- **合規要求**：必須在部署前通過的安全和監管檢查
- **成本效益預防**：早期捕獲成本低但在生產環境中修復成本高的問題
- **確定性行為**：行為可預測且可以完全測試的功能

**何時強調右移：**

- **未知的未知**：你無法提前預測或測試的問題
- **規模依賴問題**：只在生產負載下出現的行為
- **使用者行為**：真實使用者實際如何與你的系統互動
- **基礎設施複雜性**：具有突發故障模式的分散式系統
- **快速創新**：當上市速度超過完美的預生產測試時

!!!success "✨ 理想的平衡"
    **左移**以在生產環境之前捕獲你能捕獲的。
    **右移**以處理你無法捕獲的。
    
    它們共同創造了完整的品質策略：
    - 預防可預測的問題（左移）
    - 快速偵測不可預測的問題（右移）
    - 從生產環境中學習以改進預防（回饋循環）

## 開始右移

準備好實施右移實踐了嗎？這裡有一個實用的路線圖：

### 第一階段：基礎（第 1-4 週）

**改進可觀測性：**
- 在服務之間實施結構化日誌
- 為關鍵路徑新增分散式追蹤
- 為關鍵業務指標建立儀表板
- 為異常設定警報

**從小處開始：**
- 從一個服務或元件開始
- 在更改任何內容之前專注於理解當前行為
- 記錄你學到的東西

### 第二階段：漸進式交付（第 5-8 週）

**實施特性開關：**
- 選擇特性開關平台（LaunchDarkly、Split 或開源替代方案）
- 從一個開關後面的新功能開始
- 透過逐步推出練習金絲雀發布
- 建立開關衛生實踐

**合成監控：**
- 識別關鍵使用者旅程
- 建立針對生產環境執行的自動化測試
- 為測試失敗設定警報
- 逐步擴大覆蓋範圍

### 第三階段：韌性測試（第 9-12 週）

**混沌工程：**
- 在非生產環境中開始
- 在工作時間執行第一次實驗，團隊在場
- 從簡單的故障開始（終止一個實例）
- 記錄學習並修復發現的問題
- 逐步增加實驗複雜性

**事故回應：**
- 記錄當前事故回應流程
- 建立值班輪換
- 為常見問題建立執行手冊
- 透過遊戲日練習事故回應

### 第四階段：持續改進（持續進行）

**回饋循環：**
- 在事故後進行無責備事後分析
- 追蹤行動項目直到完成
- 跨團隊分享學習
- 測量和改進關鍵指標（MTTR、部署頻率、變更失敗率）

**文化：**
- 慶祝從失敗中學習
- 獎勵提高韌性的團隊
- 與開發團隊分享生產洞察
- 讓每個人都能存取可觀測性資料

!!!tip "🎯 成功指標"
    追蹤這些指標以衡量右移的有效性：
    
    - **平均偵測時間（MTTD）**：你發現問題的速度
    - **平均恢復時間（MTTR）**：你解決問題的速度
    - **變更失敗率**：導致事故的部署百分比
    - **部署頻率**：你可以安全部署的頻率
    - **客戶影響**：受事故影響的使用者百分比
    
    右移實踐應該隨著時間的推移改善所有這些指標。

## 結論：完成 DevOps 循環

左移透過儘早捕獲問題改變了軟體開發。它減少了 bug，提高了安全性，並加速了交付。這些成就是真實且有價值的。

但僅靠左移是不完整的。生產環境太複雜，使用者行為太不可預測，基礎設施太分散式，預生產測試無法捕獲所有內容。我們需要將生產環境視為學習環境的實踐。

右移完成了 DevOps 循環。它透過可觀測性、漸進式交付、混沌工程、生產測試和持續學習將品質實踐擴展到部署之外。與左移一起，它創造了軟體品質的綜合方法：

- **預防**你在生產環境之前能預防的（左移）
- **偵測**你無法預防的快速偵測（右移）
- **學習**從生產環境中學習以改進預防（回饋循環）

DevOps 的未來不是在左移和右移之間做選擇——而是掌握兩者。做到這一點的組織將建構更具韌性的系統，更快地回應事故，並為使用者提供更好的體驗。

問題不是是否要右移。而是你能多快開始。

!!!quote "💭 最後的思考"
    「希望不是策略，恐懼也不是。左移透過預防降低風險。右移透過韌性建立信心。它們共同改變了我們建構和營運軟體的方式。」
