---
title: "緩慢變化維度：管理資料倉儲中的歷史資料"
date: 2006-12-11
lang: zh-TW
categories: Architecture
tags: [Data Warehousing, Database, Data Modeling]
excerpt: "維度資料會以不可預測的方式隨時間變化。從簡單的覆寫到複雜的混合方法，理解 SCD 類型有助於平衡歷史準確性、資料完整性和系統效能。"
---

資料倉儲承諾提供歷史分析，但維度資料卻不願保持靜止。客戶搬遷、產品變更類別、業務員調到新區域。這些變化看似簡單，直到你問：歷史報表應該反映舊狀態還是新狀態？

傳統資料庫透過更新處理變化——用新值覆寫舊值。這對專注於當前狀態的交易系統有效，但會破壞使資料倉儲有價值的歷史脈絡。當業務員從加州調到伊利諾州時，他們過去的銷售額應該出現在加州還是伊利諾州的區域報表中？

緩慢變化維度（SCD）解決了這個挑戰。與快速變化的交易資料（客戶 ID、數量、價格）不同，維度屬性如位置、名稱和類別的變化頻率較低但不可預測。SCD 中的「緩慢」並不意味著變化罕見，而是指它們不是正常交易流程的一部分。

Ralph Kimball 的《資料倉儲工具包》推廣了處理這些變化的分類系統：類型 0 到 7。每種類型代表歷史準確性、資料複雜性和查詢效能之間的不同權衡。類型 1 犧牲歷史以換取簡單性。類型 2 以複雜性為代價保留完整歷史。類型 6 結合多種方法以獲得最大靈活性。

挑戰不僅限於技術實作。SCD 必須維護事實表和維度表之間的參照完整性。銷售事實表連結到供應商維度。當供應商搬遷時，歷史銷售記錄必須仍然連接到正確的供應商資訊，而不破壞資料庫關係。

本文探討每種 SCD 類型，檢視其權衡，並提供針對不同情境選擇正確方法的指導。


## 歷史資料問題

在探索解決方案之前，理解問題可以揭示為什麼維度變化會產生複雜性。

### 供應商搬遷情境

考慮一個追蹤供應商關係的資料倉儲：

!!!anote "📊 初始狀態"
    **供應商維度**
    - 供應商：Acme Supply Co
    - 位置：加州
    - 供應商代碼：ABC
    
    **事實表**
    - 2005 年銷售額：$500,000
    - 2006 年銷售額：$750,000
    
    **業務問題**
    「我們 2005 年在加州的供應商銷售額是多少？」

答案似乎很明顯：$500,000。但當 Acme 在 2007 年搬遷到伊利諾州時，問題變得模糊。報表應該顯示：

1. **當前狀態**：加州銷售額為零（Acme 現在在伊利諾州）
2. **歷史狀態**：$500,000（Acme 在 2005 年時在加州）
3. **兩者皆可**：取決於查詢

不同的業務需求需要不同的答案。稅務報告需要歷史準確性——銷售發生在加州，無論當前位置如何。策略規劃可能需要當前狀態——了解當前供應商分佈比過去位置更重要。

### 參照完整性挑戰

資料庫關係使事情變得更加複雜：

!!!error "🚫 更新問題"
    **情境**
    - 事實表參照 Supplier_Key = 123
    - 供應商 123 是「Acme Supply Co, CA」
    - 供應商搬遷到伊利諾州
    
    **選項 1：就地更新**
    - 將供應商 123 改為「Acme Supply Co, IL」
    - 歷史事實現在顯示伊利諾州
    - 損失：歷史準確性
    
    **選項 2：建立新記錄**
    - 新增供應商 124 為「Acme Supply Co, IL」
    - 保留供應商 123 為「Acme Supply Co, CA」
    - 問題：新交易使用哪個鍵？
    - 問題：如何查詢「所有 Acme 交易」？

兩種選項都無法滿足所有需求。更新會破壞歷史。新記錄會破壞自然鍵關係。SCD 提供了結構化的方法來解決這個困境。

### 為什麼「緩慢變化」很重要

緩慢變化和快速變化資料之間的區別至關重要：

!!!anote "🔄 變化頻率比較"
    **快速變化（交易型）**
    - 每筆訂單中的客戶 ID
    - 每筆銷售中的產品 ID
    - 數量、價格、日期
    - 變化：每天數百萬次
    - 策略：儲存每筆交易
    
    **緩慢變化（維度型）**
    - 客戶地址
    - 產品類別
    - 供應商位置
    - 變化：每月數十次
    - 策略：取決於業務需求

交易資料變化是預期的且經過設計。維度變化是需要特殊處理的例外。「緩慢」限定詞表示這些變化發生在正常交易流程之外，使它們更難預測和管理。


## SCD 類型分類

Ralph Kimball 的分類系統提供了處理維度變化的結構化方法。

### 類型系統概述

!!!anote "📋 SCD 類型一覽"
    **類型 0：保留原始值**
    - 永不改變
    - 保留原始值
    - 範例：出生日期
    
    **類型 1：覆寫**
    - 用新值替換舊值
    - 不維護歷史
    - 最簡單的方法
    
    **類型 2：新增列**
    - 為每次變化建立新記錄
    - 保留完整歷史
    - 最常見的方法
    
    **類型 3：新增屬性**
    - 在欄位中儲存有限歷史
    - 僅追蹤前一個值
    - 簡單查詢
    
    **類型 4：新增歷史表**
    - 獨立的歷史表
    - 當前和歷史資料分離
    - 稽核式追蹤
    
    **類型 6：組合方法（1+2+3）**
    - 混合方法
    - 多種追蹤方法
    - 最大靈活性
    
    **類型 7：雙鍵**
    - 代理鍵和自然鍵
    - 靈活的查詢選項
    - 複雜實作

每種類型代表不同的優先順序。類型 1 優先考慮簡單性而非歷史。類型 2 優先考慮歷史而非簡單性。類型 6 試圖以複雜性為代價提供兩者。

### 選擇因素

正確的類型取決於具體需求：

!!!anote "🎯 決策因素"
    **歷史準確性**
    - 過去狀態有多重要？
    - 法規要求？
    - 需要稽核軌跡？
    
    **查詢模式**
    - 當前狀態查詢？
    - 歷史狀態查詢？
    - 兩種類型都需要？
    
    **資料量**
    - 變化多久發生一次？
    - 儲存限制？
    - 效能要求？
    
    **複雜度容忍度**
    - 團隊專業知識？
    - 維護負擔？
    - ETL 複雜性可接受？

沒有單一類型適合所有情境。許多資料倉儲對不同維度使用不同類型，甚至對同一維度內的不同屬性使用不同類型。


## 類型 0：保留原始值

某些屬性根據定義永不改變。

### 不可變屬性

類型 0 適用於具有持久值的屬性：

!!!success "✅ 類型 0 特性"
    **定義**
    - 屬性永不改變
    - 原始值永久保留
    - 不需要特殊處理
    
    **常見範例**
    - 出生日期
    - 原始信用評分
    - 帳戶建立日期
    - 初始分類
    
    **實作**
    - 標準欄位
    - 無更新邏輯
    - 最簡單的方法

類型 0 實際上不是「緩慢變化」維度——它是「永不變化」維度。此分類的存在是為了明確識別永遠不應更新的屬性，防止意外修改。

### 日期維度

日期維度通常對大多數屬性使用類型 0：

```sql
CREATE TABLE Date_Dimension (
    Date_Key INT PRIMARY KEY,
    Full_Date DATE,
    Day_Of_Week VARCHAR(10),
    Month_Name VARCHAR(10),
    Quarter INT,
    Year INT,
    Is_Holiday BOOLEAN
);
```

!!!anote "📅 日期維度穩定性"
    **為什麼類型 0 有效**
    - 2006 年 1 月 1 日永遠是 2006 年 1 月 1 日
    - 給定日期的星期幾永不改變
    - 季度和年份是固定的
    
    **例外：Is_Holiday**
    - 假日指定可能會改變
    - 宣布新假日
    - 可能需要類型 1 或類型 2

日期維度展示了類型 0 的簡單性。一旦填充，它們很少需要更新。這種穩定性使它們成為事實表連接和基於時間分析的理想選擇。

### 業務價值

類型 0 提供清晰度和保護：

!!!success "✅ 類型 0 優勢"
    **清晰度**
    - 明確標記不可變資料
    - 記錄業務規則
    - 防止混淆
    
    **保護**
    - 無意外更新
    - 保證資料完整性
    - 稽核合規
    
    **效能**
    - 無版本檢查
    - 簡單查詢
    - 最小儲存

在設計期間識別類型 0 屬性可以防止未來問題。當業務規則聲明「這永不改變」時，類型 0 在資料模型層級強制執行該規則。


## 類型 1：覆寫

最簡單的方法：用新值替換舊值。

### 類型 1 如何運作

類型 1 就地更新記錄：

**初始狀態：**

| Supplier_Key | Supplier_Code | Supplier_Name | Supplier_State |
|--------------|---------------|---------------|----------------|
| 123 | ABC | Acme Supply Co | CA |

**搬遷後：**

| Supplier_Key | Supplier_Code | Supplier_Name | Supplier_State |
|--------------|---------------|---------------|----------------|
| 123 | ABC | Acme Supply Co | IL |

```sql
UPDATE Supplier
SET Supplier_State = 'IL'
WHERE Supplier_Code = 'ABC';
```

舊值消失。新值取而代之。沒有歷史，沒有複雜性。

### 何時類型 1 有意義

類型 1 適用於特定情境：

!!!success "✅ 良好的類型 1 使用案例"
    **錯誤更正**
    - 資料輸入中的錯字
    - 不正確的初始值
    - 資料品質修正
    - 錯誤不需要歷史
    
    **無關緊要的變化**
    - 不影響分析的變化
    - 外觀更新
    - 標準化變化
    - 範例：「St.」改為「Street」
    
    **僅當前狀態**
    - 不需要歷史報告
    - 當前快照足夠
    - 儲存限制
    - 簡單報告需求

供應商的電話號碼可能使用類型 1。歷史電話號碼很少對分析重要。當號碼改變時，覆寫它。報表始終顯示當前聯絡資訊。

### 簡單性的代價

類型 1 的簡單性伴隨著重大限制：

!!!error "🚫 類型 1 限制"
    **歷史遺失**
    - 無法回答「2005 年的值是什麼？」
    - 稽核軌跡被破壞
    - 合規問題
    - 不可逆的資料遺失
    
    **彙總影響**
    - 預先計算的彙總變得不正確
    - 必須重新計算摘要
    - 範例：「按州銷售」追溯變化
    - 效能影響
    
    **報告混淆**
    - 歷史報表顯示當前值
    - 「加州銷售」在搬遷後顯示零
    - 業務使用者困惑
    - 對資料的信任受損

### 彙總重新計算問題

類型 1 產生級聯更新：

!!!warning "⚠️ 彙總維護"
    **情境**
    - 彙總表：按供應商州的銷售
    - 加州總計：$5,000,000
    - 伊利諾州總計：$2,000,000
    
    **類型 1 更新後**
    - 供應商從 CA 搬到 IL
    - 彙總表現在不正確
    - 必須重新計算：
      - 從加州減去
      - 加到伊利諾州
    
    **問題**
    - 昂貴的重新計算
    - 影響多個彙總表
    - ETL 複雜性增加
    - 違背彙總的目的

預先計算的彙總存在是為了效能。類型 1 變化強制重新計算，抵消了效能優勢。這使得類型 1 不適合用於彙總表中的維度。

### 實作考量

類型 1 需要仔細規劃：

!!!tip "💡 類型 1 最佳實踐"
    **記錄決策**
    - 明確標記類型 1 屬性
    - 解釋為什麼不需要歷史
    - 獲得業務簽核
    
    **稽核軌跡替代方案**
    - 考慮資料庫稽核日誌
    - 獨立稽核表
    - 折衷：簡單更新，外部歷史
    
    **混合方法**
    - 某些屬性使用類型 1
    - 其他屬性使用類型 2
    - 同一維度，不同策略

類型 1 與其他類型結合使用效果最佳。對歷史真正不重要的屬性使用類型 1，對重要的屬性使用類型 2。


## 類型 2：新增列

最常見的 SCD 方法：為每次變化建立新記錄。

### 類型 2 如何運作

類型 2 透過多筆記錄保留完整歷史：

**初始狀態：**

| Supplier_Key | Supplier_Code | Supplier_Name | Supplier_State | Version |
|--------------|---------------|---------------|----------------|---------|
| 123 | ABC | Acme Supply Co | CA | 0 |

**第一次搬遷後：**

| Supplier_Key | Supplier_Code | Supplier_Name | Supplier_State | Version |
|--------------|---------------|---------------|----------------|---------|
| 123 | ABC | Acme Supply Co | CA | 0 |
| 124 | ABC | Acme Supply Co | IL | 1 |

每次變化都會建立一個具有新代理鍵的新列。自然鍵（Supplier_Code）保持不變，但代理鍵（Supplier_Key）會改變。

### 實作變化

類型 2 有幾種實作模式：

!!!anote "🔧 類型 2 實作選項"
    **版本號**
    - 順序版本欄位
    - 易於理解
    - 容易找到最新版本
    
    **生效日期**
    - Start_Date 和 End_Date 欄位
    - 精確的時間追蹤
    - 支援時間點查詢
    
    **當前旗標**
    - 布林值指示當前記錄
    - 快速當前狀態查詢
    - 通常與日期結合

**生效日期實作：**

| Supplier_Key | Supplier_Code | Supplier_Name | Supplier_State | Start_Date | End_Date |
|--------------|---------------|---------------|----------------|------------|----------|
| 123 | ABC | Acme Supply Co | CA | 2000-01-01 | 2004-12-22 |
| 124 | ABC | Acme Supply Co | IL | 2004-12-22 | NULL |

NULL End_Date 表示當前記錄。某些實作使用高日期值（9999-12-31）而不是 NULL，以避免在查詢中處理 null。

**當前旗標實作：**

| Supplier_Key | Supplier_Code | Supplier_Name | Supplier_State | Effective_Date | Current_Flag |
|--------------|---------------|---------------|----------------|----------------|--------------|
| 123 | ABC | Acme Supply Co | CA | 2000-01-01 | N |
| 124 | ABC | Acme Supply Co | IL | 2004-12-22 | Y |

Current_Flag 啟用快速篩選：`WHERE Current_Flag = 'Y'` 僅返回當前記錄。

### 事實表整合

類型 2 的威力來自事實表整合：

!!!success "✅ 類型 2 優勢"
    **歷史準確性**
    - 事實連結到正確的歷史維度
    - 2003 年的交易連結到 Supplier_Key 123（CA）
    - 2005 年的交易連結到 Supplier_Key 124（IL）
    - 報表顯示準確的歷史狀態
    
    **無彙總更新**
    - 彙總保持正確
    - 「按州銷售」不會追溯變化
    - 預先計算的摘要保持有效
    - 維持效能
    
    **無限歷史**
    - 追蹤每次變化
    - 完整稽核軌跡
    - 支援合規要求
    - 可能的時間旅行查詢

當事實表儲存 Supplier_Key 時，它會捕獲交易時的維度狀態。2003 年的銷售參照 Supplier_Key 123（加州）。即使供應商搬遷，該關係也永不改變。歷史報表自動顯示正確狀態。

### 查詢模式

類型 2 支援多種查詢模式：

**當前狀態查詢：**

```sql
SELECT 
    s.Supplier_Name,
    s.Supplier_State,
    SUM(f.Sales_Amount) as Total_Sales
FROM Fact_Sales f
JOIN Supplier s ON f.Supplier_Key = s.Supplier_Key
WHERE s.Current_Flag = 'Y'
GROUP BY s.Supplier_Name, s.Supplier_State;
```

**歷史狀態查詢：**

```sql
SELECT 
    s.Supplier_Name,
    s.Supplier_State,
    SUM(f.Sales_Amount) as Total_Sales
FROM Fact_Sales f
JOIN Supplier s ON f.Supplier_Key = s.Supplier_Key
WHERE f.Sale_Date BETWEEN s.Start_Date AND s.End_Date
GROUP BY s.Supplier_Name, s.Supplier_State;
```

**時間點查詢：**

```sql
SELECT 
    s.Supplier_Name,
    s.Supplier_State
FROM Supplier s
WHERE s.Supplier_Code = 'ABC'
  AND '2003-06-15' BETWEEN s.Start_Date AND COALESCE(s.End_Date, '9999-12-31');
```

### 類型 2 挑戰

儘管很受歡迎，類型 2 仍有缺點：

!!!warning "⚠️ 類型 2 挑戰"
    **維度大小增長**
    - 每次變化都會新增一列
    - 頻繁變化的維度變得很大
    - 儲存影響
    - 索引維護開銷
    
    **ETL 複雜性**
    - 必須檢測變化
    - 關閉舊記錄（設定 End_Date）
    - 建立新記錄
    - 更新 Current_Flag
    - 比類型 1 更複雜
    
    **自然鍵查詢**
    - 每個自然鍵有多列
    - 必須指定時間段或當前旗標
    - 連接變得更複雜
    - 重複結果的風險
    
    **追溯變化**
    - 新增新屬性很困難
    - 不同屬性的生效日期不同
    - 可能需要重新處理事實
    - 昂貴的操作

### 追溯變化問題

類型 2 最大的挑戰出現在維度模型變化時：

!!!error "🚫 追溯變化情境"
    **情況**
    - 維度追蹤 Supplier_State
    - 業務新增需求：追蹤 Sales_Rep
    - Sales_Rep 的生效日期與 State 不同
    
    **問題**
    - 現有列有 State 變化
    - 需要新增 Sales_Rep 變化
    - 生效日期不一致
    - 必須建立新的時間切片
    
    **影響**
    - 現有事實記錄指向舊鍵
    - 必須更新事實表
    - 昂貴的操作
    - 潛在的資料不一致

這種情境使得類型 2 不適合經常進行結構變化的維度。當模型演變時，維護類型 2 的成本可能變得過高。

### 最佳實踐

類型 2 需要紀律才能發揮最佳效果：

!!!tip "💡 類型 2 最佳實踐"
    **需要代理鍵**
    - 事實中永不使用自然鍵
    - 代理鍵啟用版本控制
    - 簡化鍵管理
    
    **一致的日期處理**
    - 標準化使用 NULL 或高日期
    - 記錄慣例
    - 在 ETL 中強制執行
    
    **索引策略**
    - 為當前查詢索引 Current_Flag
    - 為時間查詢索引 Start_Date 和 End_Date
    - 為查找索引自然鍵
    
    **ETL 變化檢測**
    - 將來源與當前維度比較
    - 有效檢測變化
    - 批次更新以提高效能

類型 2 是大多數緩慢變化維度的預設選擇。其歷史準確性和查詢靈活性的結合使其適用於廣泛的情境。


## 類型 3：新增屬性

類型 3 透過額外欄位追蹤有限歷史。

### 類型 3 如何運作

類型 3 不是新增列，而是新增欄位：

**初始狀態：**

| Supplier_Key | Supplier_Code | Supplier_Name | Current_State |
|--------------|---------------|---------------|---------------|
| 123 | ABC | Acme Supply Co | CA |

**新增類型 3 追蹤後：**

| Supplier_Key | Supplier_Code | Supplier_Name | Original_State | Effective_Date | Current_State |
|--------------|---------------|---------------|----------------|----------------|---------------|
| 123 | ABC | Acme Supply Co | CA | 2004-12-22 | IL |

表結構改變以容納歷史。Original_State 保留第一個值。Current_State 保存最新值。

### 有限歷史權衡

類型 3 提供固定的歷史深度：

!!!anote "📊 類型 3 特性"
    **追蹤內容**
    - 原始值
    - 當前值
    - 一個轉換日期
    - 無中間變化
    
    **限制**
    - 僅兩個狀態可見
    - 第二次搬遷會覆寫第一次變化
    - 無法追蹤多次轉換
    - 固定欄位結構
    
    **優勢**
    - 簡單查詢
    - 無列倍增
    - 固定表大小
    - 易於理解

### 查詢簡單性

類型 3 啟用直接的查詢：

```sql
-- 當前狀態分析
SELECT 
    Current_State,
    SUM(Sales_Amount) as Total_Sales
FROM Supplier s
JOIN Fact_Sales f ON s.Supplier_Key = f.Supplier_Key
GROUP BY Current_State;

-- 原始狀態分析
SELECT 
    Original_State,
    SUM(Sales_Amount) as Total_Sales
FROM Supplier s
JOIN Fact_Sales f ON s.Supplier_Key = f.Supplier_Key
GROUP BY Original_State;

-- 轉換分析
SELECT 
    Original_State,
    Current_State,
    COUNT(*) as Suppliers_Moved
FROM Supplier
WHERE Original_State != Current_State
GROUP BY Original_State, Current_State;
```

無日期範圍檢查。無當前旗標。簡單的欄位參照。

### 何時類型 3 有意義

類型 3 適用於特定的分析需求：

!!!success "✅ 良好的類型 3 使用案例"
    **前後分析**
    - 比較原始與當前
    - 遷移追蹤
    - 範例：「從城市搬到鄉村的客戶」
    
    **固定轉換**
    - 預期的一次變化
    - 範例：產品發布狀態（Beta → 已發布）
    - 範例：客戶層級（標準 → 高級）
    
    **簡單報告**
    - 業務只需要兩個視圖
    - 當前和原始就足夠
    - 不需要中間狀態

### 前一個值變化

另一種方法追蹤最近的變化：

| Supplier_Key | Supplier_Code | Supplier_Name | Previous_State | Change_Date | Current_State |
|--------------|---------------|---------------|----------------|-------------|---------------|
| 123 | ABC | Acme Supply Co | CA | 2004-12-22 | IL |

**第二次搬遷後：**

| Supplier_Key | Supplier_Code | Supplier_Name | Previous_State | Change_Date | Current_State |
|--------------|---------------|---------------|----------------|-------------|---------------|
| 123 | ABC | Acme Supply Co | IL | 2008-02-04 | NY |

Previous_State 現在顯示 IL（不是 CA）。此變化追蹤最後一次轉換，失去了更早的歷史。

### 類型 3 限制

固定結構產生問題：

!!!error "🚫 類型 3 問題"
    **歷史遺失**
    - 第三次變化覆寫第二次
    - 無法重建完整歷史
    - 稽核軌跡不完整
    
    **架構變化**
    - 新增更多歷史需要 ALTER TABLE
    - 需要應用程式變化
    - 對生產環境造成干擾
    
    **時間查詢不可能**
    - 無法詢問「日期 X 的值是什麼？」
    - 僅兩個時間點可用
    - 有限的分析價值
    
    **事實表模糊性**
    - 哪個狀態適用於給定交易？
    - 必須將交易日期與 Effective_Date 比較
    - 比類型 2 更複雜

### 混合欄位方法

類型 3 通常與其他類型結合：

!!!tip "💡 類型 3 混合策略"
    **情境**
    - 使用類型 2 獲得完整歷史
    - 為常見查詢新增類型 3 欄位
    - 範例：類型 2 維度中的 Current_State 欄位
    
    **優勢**
    - 類型 2 提供完整歷史
    - 類型 3 欄位簡化頻繁查詢
    - 兩種方法的優點
    
    **權衡**
    - 冗餘資料
    - ETL 必須維護兩者
    - 儲存開銷

類型 3 很少單獨使用。其有限的歷史使其不適合作為唯一的追蹤機制。與類型 2 結合，它在維護完整歷史的同時提供查詢便利性。


## 類型 4：新增歷史表

類型 4 將當前和歷史資料分離到不同的表中。

### 類型 4 如何運作

類型 4 使用兩個表：一個用於當前狀態，一個用於歷史：

**Supplier 表（當前）：**

| Supplier_Key | Supplier_Code | Supplier_Name | Supplier_State |
|--------------|---------------|---------------|----------------|
| 124 | ABC | Acme & Johnson Supply Co | IL |

**Supplier_History 表：**

| Supplier_Key | Supplier_Code | Supplier_Name | Supplier_State | Create_Date |
|--------------|---------------|---------------|----------------|-------------|
| 123 | ABC | Acme Supply Co | CA | 2003-06-14 |
| 124 | ABC | Acme & Johnson Supply Co | IL | 2004-12-22 |

當前表僅包含活動記錄。歷史表包含所有版本，包括當前版本。

### 資料庫稽核模式

類型 4 類似於資料庫稽核表：

!!!anote "🔍 類型 4 特性"
    **結構**
    - 當前表：每個實體一列
    - 歷史表：所有版本
    - 兩個表共享鍵結構
    - 歷史包含時間戳記
    
    **與稽核表的相似性**
    - 追蹤所有變化
    - 不可變歷史
    - 基於時間戳記
    - 獨立儲存
    
    **與稽核表的差異**
    - 歷史表是可查詢的維度
    - 事實表可以參照兩者
    - 維度模型的一部分
    - 不僅用於稽核

### 事實表整合

類型 4 的獨特功能：事實可以參照兩個表：

```sql
CREATE TABLE Fact_Sales (
    Sale_ID INT PRIMARY KEY,
    Sale_Date DATE,
    Current_Supplier_Key INT,  -- 參照 Supplier
    Historical_Supplier_Key INT, -- 參照 Supplier_History
    Amount DECIMAL(10,2)
);
```

!!!success "✅ 雙重參照優勢"
    **當前狀態查詢**
    - 連接到 Supplier 表
    - 始終顯示當前資訊
    - 快速查詢（較小的表）
    - 不需要日期篩選
    
    **歷史狀態查詢**
    - 連接到 Supplier_History 表
    - 顯示交易時的狀態
    - 完整稽核軌跡
    - 時間準確性
    
    **靈活性**
    - 每次查詢選擇適當的表
    - 不需要重寫查詢
    - 兩種視圖都可用

### 查詢模式

類型 4 啟用不同的分析視角：

**當前狀態分析：**

```sql
SELECT 
    s.Supplier_State,
    SUM(f.Amount) as Total_Sales
FROM Fact_Sales f
JOIN Supplier s ON f.Current_Supplier_Key = s.Supplier_Key
GROUP BY s.Supplier_State;
```

此查詢顯示按當前供應商州分組的所有銷售，無論銷售何時發生。

**歷史狀態分析：**

```sql
SELECT 
    sh.Supplier_State,
    SUM(f.Amount) as Total_Sales
FROM Fact_Sales f
JOIN Supplier_History sh ON f.Historical_Supplier_Key = sh.Supplier_Key
GROUP BY sh.Supplier_State;
```

此查詢顯示按銷售時供應商州分組的銷售。

### ETL 考量

類型 4 需要仔細的 ETL 設計：

!!!warning "⚠️ 類型 4 ETL 複雜性"
    **變化檢測**
    - 將來源與當前表比較
    - 檢測變化
    - 更新當前表
    - 插入歷史表
    
    **鍵管理**
    - 為變化生成新代理鍵
    - 用新鍵更新當前表
    - 在歷史表中插入新列
    - 用兩個鍵更新事實表
    
    **事實表載入**
    - 必須填充兩個鍵欄位
    - 當前鍵：最新維度鍵
    - 歷史鍵：交易時的維度鍵
    - 需要時間查找

### 何時類型 4 有意義

類型 4 適合特定情境：

!!!success "✅ 良好的類型 4 使用案例"
    **雙重視角報告**
    - 需要當前和歷史視圖
    - 頻繁在視角之間切換
    - 範例：按當前區域與歷史區域的銷售
    
    **效能優化**
    - 當前表保持小型
    - 快速當前狀態查詢
    - 歷史表可以分區
    - 獨立索引策略
    
    **變化資料捕獲**
    - 與 CDC 系統整合
    - 自然適合 CDC 輸出
    - 稽核軌跡要求
    - 合規需求

### 類型 4 挑戰

雙表方法產生複雜性：

!!!error "🚫 類型 4 問題"
    **事實表開銷**
    - 每個維度兩個鍵欄位
    - 增加儲存
    - 更複雜的 ETL
    - 潛在的不一致
    
    **同步風險**
    - 當前和歷史表必須保持一致
    - 歷史表應包含當前記錄
    - ETL 失敗可能導致分歧
    - 驗證開銷
    
    **查詢混淆**
    - 使用者必須了解使用哪個表
    - 錯誤的表選擇給出錯誤結果
    - 文件至關重要
    - 需要培訓
    
    **有限的工具支援**
    - BI 工具期望單一維度表
    - 可能無法很好地處理雙重參照
    - 需要自訂查詢邏輯
    - 報告複雜性

### 維護策略

類型 4 需要持續維護：

!!!tip "💡 類型 4 最佳實踐"
    **一致性檢查**
    - 驗證歷史包含當前記錄
    - 驗證鍵關係
    - 定期對帳
    - 自動驗證
    
    **清晰命名**
    - 明顯的表名（當前 vs 歷史）
    - 描述性鍵欄位名稱
    - 資料字典中的文件
    
    **ETL 原子性**
    - 在單一交易中更新兩個表
    - 失敗時回滾
    - 防止部分更新
    
    **效能調整**
    - 按日期分區歷史表
    - 每個表不同的索引
    - 如需要存檔舊歷史

類型 4 以複雜性為代價提供靈活性。當真正需要雙重視角且團隊可以管理額外的 ETL 和維護負擔時，它效果最佳。


## 類型 6：組合方法

類型 6 結合類型 1、2 和 3（1 + 2 + 3 = 6）以獲得最大靈活性。

### 類型 6 如何運作

類型 6 使用類型 2 的列版本控制，加上類型 3 的當前值欄位和類型 1 的覆寫策略：

**初始狀態：**

| Supplier_Key | Row_Key | Supplier_Code | Supplier_Name | Current_State | Historical_State | Start_Date | End_Date | Current_Flag |
|--------------|---------|---------------|---------------|---------------|------------------|------------|----------|--------------|
| 123 | 1 | ABC | Acme Supply Co | CA | CA | 2000-01-01 | 9999-12-31 | Y |

**第一次搬遷後：**

| Supplier_Key | Row_Key | Supplier_Code | Supplier_Name | Current_State | Historical_State | Start_Date | End_Date | Current_Flag |
|--------------|---------|---------------|---------------|---------------|------------------|------------|----------|--------------|
| 123 | 1 | ABC | Acme Supply Co | IL | CA | 2000-01-01 | 2004-12-22 | N |
| 123 | 2 | ABC | Acme Supply Co | IL | IL | 2004-12-22 | 9999-12-31 | Y |

注意：
- 類型 2：建立新列（Row_Key 2）
- 類型 3：新增 Current_State 欄位
- 類型 1：Row_Key 1 中的 Current_State 覆寫為 IL

**第二次搬遷後：**

| Supplier_Key | Row_Key | Supplier_Code | Supplier_Name | Current_State | Historical_State | Start_Date | End_Date | Current_Flag |
|--------------|---------|---------------|---------------|---------------|------------------|------------|----------|--------------|
| 123 | 1 | ABC | Acme Supply Co | NY | CA | 2000-01-01 | 2004-12-22 | N |
| 123 | 2 | ABC | Acme Supply Co | NY | IL | 2004-12-22 | 2008-02-04 | N |
| 123 | 3 | ABC | Acme Supply Co | NY | NY | 2008-02-04 | 9999-12-31 | Y |

所有列現在顯示 Current_State = NY（類型 1 覆寫），而 Historical_State 保留每個時間段內當前的值（類型 2 歷史）。

### 三種技術的結合

類型 6 將每種技術應用於不同方面：

!!!anote "🔧 類型 6 機制"
    **類型 1 組件**
    - Current_State 欄位
    - 每次變化時覆寫
    - 所有列更新以顯示最新值
    - 啟用「當前狀態」查詢
    
    **類型 2 組件**
    - 每次變化新增列
    - Start_Date 和 End_Date
    - Current_Flag
    - 保留完整歷史
    
    **類型 3 組件**
    - Historical_State 欄位
    - 儲存時間段內當前的值
    - 建立後永不更新
    - 啟用「歷史狀態」查詢

### 查詢靈活性

類型 6 支援三種查詢模式：

**當前狀態查詢：**

```sql
SELECT 
    s.Current_State,
    SUM(f.Sales_Amount) as Total_Sales
FROM Fact_Sales f
JOIN Supplier s ON f.Supplier_Key = s.Row_Key
GROUP BY s.Current_State;
```

顯示按當前供應商州分組的所有銷售。簡單連接，無日期篩選。

**歷史狀態查詢：**

```sql
SELECT 
    s.Historical_State,
    SUM(f.Sales_Amount) as Total_Sales
FROM Fact_Sales f
JOIN Supplier s ON f.Supplier_Key = s.Row_Key
GROUP BY s.Historical_State;
```

顯示按銷售發生時當前的州分組的銷售。同樣簡單，不需要日期篩選。

**時間點查詢：**

```sql
SELECT 
    s.Supplier_Name,
    s.Historical_State
FROM Supplier s
WHERE s.Supplier_Code = 'ABC'
  AND '2005-06-15' BETWEEN s.Start_Date AND s.End_Date;
```

檢索特定日期時存在的維度狀態。

### Kimball 的「具有單一版本覆蓋的不可預測變化」

Ralph Kimball 將類型 6 稱為「具有單一版本覆蓋的不可預測變化」：

!!!anote "📚 Kimball 的術語"
    **不可預測變化**
    - 變化不規則發生
    - 無法預測何時或多久發生一次
    - 緩慢變化維度的典型特徵
    
    **單一版本覆蓋**
    - 當前值「覆蓋」在所有歷史列上
    - 建立當前狀態的單一版本
    - 無需日期邏輯即可存取
    - 簡化常見查詢

「覆蓋」指的是在所有列中更新的 Current_State 欄位，無論您檢查哪個歷史列，都提供當前狀態的單一、一致視圖。

### 實作複雜性

類型 6 是最複雜的 SCD 類型：

!!!warning "⚠️ 類型 6 複雜性"
    **ETL 挑戰**
    - 檢測變化（類型 2）
    - 建立新列（類型 2）
    - 更新舊列的 End_Date（類型 2）
    - 更新 Current_Flag（類型 2）
    - 更新實體的所有列的 Current_State（類型 1）
    - 最複雜的更新邏輯
    
    **儲存開銷**
    - 冗餘的 Current_State 欄位
    - 儲存在每個歷史列中
    - 增加維度大小
    - 比單獨類型 2 更多儲存
    
    **更新效能**
    - 每次變化更新多列
    - 必須更新所有歷史列
    - 對於有許多版本的實體可能很慢
    - 索引維護開銷

### 何時類型 6 有意義

類型 6 在特定情境中證明其複雜性是合理的：

!!!success "✅ 良好的類型 6 使用案例"
    **頻繁的當前狀態查詢**
    - 大多數查詢需要當前狀態
    - 偶爾需要歷史狀態
    - 查詢簡單性值得儲存成本
    
    **業務使用者查詢**
    - 非技術使用者撰寫查詢
    - 日期邏輯太複雜
    - 偏好簡單的欄位參照
    - 自助 BI 工具
    
    **法規要求**
    - 必須維護完整歷史（類型 2）
    - 必須報告當前狀態（類型 1）
    - 兩項要求都是強制性的
    - 合規證明複雜性合理

### 類型 6 最佳實踐

管理類型 6 需要紀律：

!!!tip "💡 類型 6 最佳實踐"
    **清晰的欄位命名**
    - Current_State vs Historical_State
    - 明顯區分
    - 防止查詢錯誤
    - 自我記錄
    
    **高效更新**
    - 批次 Current_State 更新
    - 使用基於集合的操作
    - 避免逐列更新
    - 優化效能
    
    **文件**
    - 解釋三種技術
    - 提供查詢範例
    - 記錄 ETL 邏輯
    - 培訓使用者
    
    **考慮類型 2 + 視圖**
    - 替代方案：類型 2 維度
    - 新增具有當前狀態的視圖
    - 視圖連接到當前列
    - 更簡單的 ETL，類似的查詢體驗

視圖替代方案提供類似的查詢簡單性，而無需更新複雜性：

```sql
CREATE VIEW Supplier_With_Current AS
SELECT 
    h.*,
    c.Supplier_State as Current_State
FROM Supplier h
JOIN Supplier c ON h.Supplier_Code = c.Supplier_Code
WHERE c.Current_Flag = 'Y';
```

此視圖使每個歷史列都能存取當前狀態，而無需冗餘儲存。


## 類型 7：雙鍵策略

類型 7 在事實表中放置代理鍵和自然鍵，以獲得最大查詢靈活性。

### 類型 7 如何運作

類型 7 使用類型 2 維度結構，但在事實中儲存兩個鍵：

**Supplier 維度（類型 2）：**

| Supplier_Key | Supplier_Code | Supplier_Name | Supplier_State | Start_Date | End_Date | Current_Flag |
|--------------|---------------|---------------|----------------|------------|----------|--------------|
| 123 | ABC | Acme Supply Co | CA | 2000-01-01 | 2004-12-22 | N |
| 124 | ABC | Acme Supply Co | IL | 2004-12-22 | 2008-02-04 | N |
| 125 | ABC | Acme Supply Co | NY | 2008-02-04 | 9999-12-31 | Y |

**具有雙鍵的事實表：**

```sql
CREATE TABLE Fact_Sales (
    Sale_ID INT PRIMARY KEY,
    Sale_Date DATE,
    Supplier_Key INT,        -- 代理鍵（歷史）
    Supplier_Code VARCHAR(10), -- 自然鍵
    Amount DECIMAL(10,2)
);
```

事實儲存交易時當前的代理鍵（Supplier_Key）和識別所有版本實體的自然鍵（Supplier_Code）。

### 查詢靈活性

類型 7 啟用三種查詢模式，無需日期邏輯：

**歷史狀態查詢：**

```sql
SELECT 
    s.Supplier_State,
    SUM(f.Amount) as Total_Sales
FROM Fact_Sales f
JOIN Supplier s ON f.Supplier_Key = s.Supplier_Key
GROUP BY s.Supplier_State;
```

在代理鍵上連接顯示歷史狀態。2003 年的銷售連接到 Supplier_Key 123（CA），顯示加州銷售。

**當前狀態查詢：**

```sql
SELECT 
    s.Supplier_State,
    SUM(f.Amount) as Total_Sales
FROM Fact_Sales f
JOIN Supplier s ON f.Supplier_Code = s.Supplier_Code
WHERE s.Current_Flag = 'Y'
GROUP BY s.Supplier_State;
```

在自然鍵上連接並使用當前旗標顯示當前狀態。ABC 的所有銷售連接到 Supplier_Key 125（NY），顯示紐約銷售。

**時間點查詢：**

```sql
SELECT 
    s.Supplier_State,
    SUM(f.Amount) as Total_Sales
FROM Fact_Sales f
JOIN Supplier s ON f.Supplier_Code = s.Supplier_Code
WHERE f.Sale_Date BETWEEN s.Start_Date AND s.End_Date
GROUP BY s.Supplier_State;
```

在自然鍵上連接並使用日期範圍顯示任何時間點的狀態。

### 相對於類型 2 的優勢

類型 7 為類型 2 增加了靈活性：

!!!success "✅ 類型 7 優勢"
    **查詢選項**
    - 歷史：在代理鍵上連接
    - 當前：在自然鍵 + 當前旗標上連接
    - 時間點：在自然鍵 + 日期範圍上連接
    - 不需要重寫查詢
    
    **參照完整性**
    - 代理鍵可以有外鍵約束
    - 自然鍵提供邏輯關係
    - 支援兩種視角
    
    **追溯變化**
    - 新增屬性不會破壞事實
    - 新時間切片不需要事實更新
    - 對維度變化更具彈性
    
    **多個日期視角**
    - 事實有 Order_Date、Ship_Date、Invoice_Date
    - 可以在不同日期上連接
    - 範例：「訂購時的供應商州」vs「發貨時」

### 追溯變化優勢

類型 7 最大的優勢出現在維度演變時：

!!!success "✅ 處理維度變化"
    **情境**
    - 維度追蹤 Supplier_State
    - 業務新增 Sales_Rep 屬性
    - Sales_Rep 有不同的變化日期
    
    **類型 2 問題**
    - 必須建立新時間切片
    - 現有事實指向舊鍵
    - 必須更新事實表
    - 昂貴的操作
    
    **類型 7 解決方案**
    - 將 Sales_Rep 新增到維度
    - 建立新時間切片
    - 事實仍有自然鍵
    - 不需要事實表更新
    - 連接邏輯處理新結構

自然鍵提供穩定性。即使維度的時間切片改變，事實仍然可以使用自然鍵和日期邏輯正確連接。

### 類型 7 挑戰

雙鍵方法有重大缺點：

!!!error "🚫 類型 7 問題"
    **無真正的參照完整性**
    - 自然鍵在維度中不唯一
    - 無法在自然鍵上建立外鍵
    - 代理鍵外鍵僅確保鍵存在
    - 不確保正確版本
    - 資料完整性依賴應用程式邏輯
    
    **查詢複雜性**
    - 使用者必須了解使用哪個鍵
    - 錯誤選擇給出錯誤結果
    - 某些查詢需要日期邏輯
    - 比類型 2 更複雜
    
    **重複列風險**
    - 沒有日期篩選的自然鍵連接返回多列
    - 容易得到錯誤結果
    - 必須記住 WHERE Current_Flag = 'Y'
    - 或日期範圍篩選
    
    **效能問題**
    - 日期比較比鍵連接慢
    - 自然鍵連接可能較慢
    - 更複雜的執行計畫
    - 索引策略至關重要
    
    **BI 工具限制**
    - 工具期望單一連接鍵
    - 可能無法很好地處理雙鍵邏輯
    - 通常需要自訂 SQL
    - 報告複雜性

### 參照完整性問題

類型 7 最嚴重的問題是無法強制執行參照完整性：

!!!error "🚫 參照完整性缺口"
    **問題**
    
    Supplier_Code 在維度中出現多次（每個版本一次）。資料庫無法在非唯一欄位上建立外鍵約束。
    
    **後果**
    - 可以插入不存在的 Supplier_Code
    - 可以插入有效代碼但錯誤的 Supplier_Key
    - 可能出現孤立事實
    - 資料品質取決於 ETL
    
    **範例**
    
    事實有 Supplier_Code = 'ABC' 和 Supplier_Key = 999。Supplier_Key 999 不存在，但 Supplier_Code 'ABC' 存在。Supplier_Key 上的外鍵會捕獲這一點，但不驗證自然鍵關係。
    
    **緩解措施**
    - ETL 驗證至關重要
    - 定期資料品質檢查
    - 應用程式層級約束
    - 無法依賴資料庫

### 何時類型 7 有意義

類型 7 適合特定情境：

!!!success "✅ 良好的類型 7 使用案例"
    **演變的維度**
    - 維度結構經常變化
    - 定期新增新屬性
    - 追溯變化常見
    - 事實表更新昂貴
    
    **多個日期視角**
    - 事實有多個日期
    - 不同日期需要不同的維度狀態
    - 範例：訂單日期 vs 發貨日期
    - 靈活性值得複雜性
    
    **進階使用者**
    - 團隊了解 SCD 概念
    - 可以撰寫正確的連接邏輯
    - 資料品質流程成熟
    - BI 工具支援複雜連接

### 類型 7 最佳實踐

類型 7 需要仔細實作：

!!!tip "💡 類型 7 最佳實踐"
    **全面文件**
    - 解釋雙鍵目的
    - 提供查詢範本
    - 記錄連接模式
    - 包含反模式（不該做什麼）
    
    **ETL 驗證**
    - 驗證兩個鍵匹配
    - 檢查自然鍵存在
    - 驗證代理鍵指向正確版本
    - 自動資料品質檢查
    
    **索引策略**
    - 在事實表中索引兩個鍵
    - 在維度中索引自然鍵
    - 索引 Start_Date 和 End_Date
    - 監控查詢效能
    
    **查詢範本**
    - 提供標準查詢
    - 當前狀態範本
    - 歷史狀態範本
    - 時間點範本
    - 防止常見錯誤
    
    **考慮替代方案**
    - 類型 2 可能就足夠
    - 類型 6 提供類似靈活性
    - 更簡單的方法通常更好
    - 複雜性必須合理

### 類型 7 vs 類型 6

兩者都提供靈活性，但透過不同機制：

!!!anote "🔍 類型 7 vs 類型 6 比較"
    **類型 6**
    - 在維度中儲存當前狀態
    - 變化時更新所有列
    - 簡單查詢（無日期邏輯）
    - 較高儲存開銷
    - 更複雜的 ETL
    
    **類型 7**
    - 在事實中儲存自然鍵
    - 不需要維度更新
    - 複雜查詢（需要日期邏輯）
    - 較低儲存開銷
    - 更簡單的 ETL，複雜的查詢
    
    **決策因素**
    - 需要查詢簡單性？→ 類型 6
    - 維度經常變化？→ 類型 7
    - 儲存受限？→ 類型 7
    - 非技術使用者？→ 類型 6

類型 7 以查詢簡單性換取 ETL 簡單性和對維度變化的彈性。正確的選擇取決於哪種複雜性對您的團隊更易於管理。


## 選擇正確的類型

不同的維度和屬性需要不同的 SCD 類型。

### 決策框架

選擇適當的 SCD 類型需要評估多個因素：

!!!anote "🎯 SCD 類型選擇標準"
    **歷史準確性要求**
    - 法規合規需求？
    - 需要稽核軌跡？
    - 歷史報告至關重要？
    - → 類型 2、類型 4 或類型 6
    
    **查詢模式**
    - 主要是當前狀態查詢？
    - 主要是歷史查詢？
    - 兩者同等重要？
    - → 影響類型 6 vs 類型 2
    
    **變化頻率**
    - 變化罕見？
    - 變化頻繁？
    - 可預測或不可預測？
    - → 影響儲存和效能
    
    **維度穩定性**
    - 結構經常變化？
    - 定期新增新屬性？
    - 需要追溯變化？
    - → 不穩定維度使用類型 7
    
    **團隊能力**
    - ETL 專業水平？
    - 查詢複雜度容忍度？
    - BI 工具限制？
    - → 經驗較少的團隊使用更簡單的類型

### 類型選擇矩陣

選擇 SCD 類型的實用指南：

| 需求 | 推薦類型 | 替代方案 | 避免 |
|------|----------|----------|------|
| 不需要歷史 | 類型 1 | 類型 0 | 類型 2+ |
| 需要完整歷史 | 類型 2 | 類型 4、類型 6 | 類型 1、類型 3 |
| 僅前後比較 | 類型 3 | 帶視圖的類型 2 | 類型 1 |
| 當前 + 歷史視圖 | 類型 6 | 類型 7、類型 4 | 類型 1、類型 3 |
| 頻繁維度變化 | 類型 7 | 類型 2 | 類型 6 |
| 簡單查詢至關重要 | 類型 1、類型 6 | 類型 3 | 類型 7 |
| 儲存受限 | 類型 1、類型 3 | 類型 2 | 類型 6 |
| 稽核合規 | 類型 2、類型 4 | 類型 6 | 類型 1 |

### 混合方法

大多數資料倉儲使用多種 SCD 類型：

!!!success "✅ 混合 SCD 類型"
    **每個維度不同類型**
    - 客戶：類型 2（地址變化重要）
    - 產品：類型 1（描述更新不重要）
    - 日期：類型 0（永不改變）
    - 員工：類型 2（部門調動追蹤）
    
    **每個屬性不同類型**
    - Customer.Address：類型 2
    - Customer.Phone：類型 1
    - Customer.Email：類型 1
    - Customer.CreditLimit：類型 2
    
    **優勢**
    - 獨立優化每個維度
    - 平衡複雜性和需求
    - 避免過度工程
    - 實用方法

### 按行業的常見模式

不同行業有典型的 SCD 模式：

!!!anote "🏢 行業模式"
    **金融服務**
    - 帳戶維度：類型 2
    - 客戶維度：類型 2
    - 產品維度：類型 2
    - 原因：法規合規、稽核要求
    
    **零售**
    - 產品維度：類型 1 或類型 2
    - 商店維度：類型 2
    - 客戶維度：類型 1 或類型 2
    - 原因：平衡歷史與簡單性
    
    **醫療保健**
    - 患者維度：類型 2
    - 提供者維度：類型 2
    - 診斷維度：類型 0
    - 原因：歷史準確性至關重要
    
    **製造業**
    - 供應商維度：類型 2
    - 產品維度：類型 2
    - 工廠維度：類型 1
    - 原因：供應鏈追蹤

### 效能考量

SCD 類型影響查詢和 ETL 效能：

!!!warning "⚠️ 效能影響"
    **類型 1**
    - 快速查詢（無日期邏輯）
    - 快速更新（簡單 UPDATE）
    - 必須重新計算彙總
    - 最佳查詢效能
    
    **類型 2**
    - 中等查詢效能
    - 日期範圍檢查增加開銷
    - 維度隨時間增長
    - 索引策略至關重要
    
    **類型 6**
    - 簡單查詢（無日期邏輯）
    - 慢速更新（多列）
    - 較大的維度大小
    - 以更新速度換取查詢速度
    
    **類型 7**
    - 複雜查詢（日期邏輯）
    - 快速更新（無維度變化）
    - 自然鍵連接可能較慢
    - 取決於索引品質

### 儲存考量

不同類型有不同的儲存特性：

!!!anote "💾 儲存影響"
    **類型 1**
    - 最小儲存
    - 每個實體一列
    - 不隨時間增長
    - 最有效
    
    **類型 2**
    - 隨變化增長
    - 每個版本一列
    - 可預測的增長率
    - 監控維度大小
    
    **類型 3**
    - 固定大小
    - 額外欄位
    - 無列倍增
    - 中等儲存
    
    **類型 6**
    - 最大儲存
    - 類型 2 列 + 冗餘欄位
    - 最高開銷
    - 以儲存成本換取查詢簡單性

### 遷移策略

變更 SCD 類型需要規劃：

!!!tip "💡 SCD 類型遷移"
    **類型 1 到類型 2**
    - 新增 Start_Date、End_Date、Current_Flag
    - 將 Start_Date 設定為最早已知日期
    - 將 End_Date 設定為 NULL
    - 未來變化使用類型 2
    - 歷史資料遺失（不可避免）
    
    **類型 2 到類型 6**
    - 新增 Current_State 欄位
    - 從當前列填充
    - 更新 ETL 以維護兩者
    - 向後相容
    
    **類型 2 到類型 1**
    - 刪除歷史列
    - 僅保留當前列
    - 移除時間欄位
    - 不可逆（先備份）

### 要避免的反模式

常見的 SCD 錯誤：

!!!error "🚫 SCD 反模式"
    **對所有內容使用類型 2**
    - 並非所有屬性都需要歷史
    - 不必要的複雜性
    - 浪費儲存
    - 解決方案：適當混合類型
    
    **對所有內容使用類型 1**
    - 失去有價值的歷史
    - 無法回答時間問題
    - 合規問題
    - 解決方案：識別關鍵歷史屬性
    
    **不一致的實作**
    - 不同的日期格式
    - 混合 NULL vs 高日期
    - 不一致的旗標值
    - 解決方案：在倉儲中標準化
    
    **忽略自然鍵**
    - 僅使用代理鍵
    - 無法跨版本查詢
    - 難以追蹤實體歷史
    - 解決方案：維護自然鍵
    
    **過度工程**
    - 類型 2 足夠時使用類型 6 或類型 7
    - 沒有好處的複雜性
    - 維護負擔
    - 解決方案：從簡單開始，僅在需要時增加複雜性

### 實用建議

實際實作的指導方針：

!!!tip "💡 實用 SCD 建議"
    **從類型 2 開始**
    - 大多數維度的預設選擇
    - 廣為理解
    - 功能的良好平衡
    - 可以演變為其他類型
    
    **謹慎使用類型 1**
    - 僅當歷史真正不重要時
    - 記錄決策
    - 獲得業務簽核
    - 考慮稽核表作為備份
    
    **最初避免類型 6 和類型 7**
    - 實作複雜
    - 維護複雜
    - 僅在類型 2 證明不足時新增
    - 需要成熟的團隊
    
    **記錄所有內容**
    - 每個維度使用哪種類型
    - 為什麼選擇該類型
    - 查詢模式和範例
    - ETL 邏輯和邊緣案例
    
    **監控和調整**
    - 追蹤維度增長
    - 監控查詢效能
    - 收集使用者回饋
    - 願意變更類型


## 結論

緩慢變化維度代表資料倉儲的基本挑戰之一：在歷史準確性與實際實作限制之間取得平衡。在 SCD 類型之間的選擇不是尋找「最佳」方法——而是將技術與業務需求、團隊能力和系統限制相匹配。

透過 SCD 類型的旅程揭示了重要的教訓：

**簡單性有代價**：類型 1 的簡單性以失去歷史為代價。在設計期間看似微小的權衡，當業務需求演變時會成為重大限制。「我們 2005 年在加州的銷售額是多少？」這個問題在供應商搬遷且類型 1 覆寫其位置後變得無法回答。歷史資料一旦失去，就無法恢復。

**歷史需要結構**：類型 2 的受歡迎程度源於其平衡的方法。完整的歷史保留、合理的查詢複雜性和廣為理解的實作使其成為預設選擇。為變化建立新列、維護時間欄位和使用代理鍵的模式已在無數資料倉儲中證明了自己。

**靈活性需要複雜性**：類型 6 和類型 7 提供最大靈活性，但需要複雜的 ETL 流程和仔細的查詢設計。只有當更簡單的方法證明不足時，複雜性才是合理的。從類型 2 開始並隨著需求的出現演變到更複雜的類型可以防止過早優化。

**情境很重要**：沒有單一的 SCD 類型適合所有情境。客戶地址可能需要類型 2 以獲得歷史準確性，而電話號碼使用類型 1 以獲得簡單性。產品類別可能需要類型 2，而產品描述使用類型 1。在單一資料倉儲內——甚至在單一維度內——混合類型的能力實現了實用的解決方案。

**權衡是不可避免的**：每種 SCD 類型代表競爭關注點之間的權衡：
- 歷史準確性 vs. 查詢簡單性
- 儲存效率 vs. 時間精確度
- ETL 複雜性 vs. 查詢靈活性
- 當前狀態存取 vs. 歷史狀態存取

理解這些權衡能夠做出明智的決策，而不是盲目遵循模式。

**實作紀律**：成功的 SCD 實作需要紀律。一致的日期處理、清晰的命名慣例、全面的文件和強大的 ETL 流程將有效的實作與有問題的實作區分開來。技術模式不如其應用的嚴謹性重要。

SCD 類型分類系統提供了討論維度變化策略的詞彙。類型 0 到類型 7 不是嚴格的規則，而是工具包。藝術在於為每種情況選擇正確的工具，在適當時組合技術，並保持紀律以一致地實作所選方法。

現代資料倉儲通常使用類型 2 作為基礎，為歷史不重要的屬性新增類型 1，僅在特定需求證明額外複雜性合理時才使用類型 6 或類型 7。這種務實的方法平衡了歷史準確性、查詢效能、儲存效率和可維護性的競爭需求。

成功的最終衡量標準不是您選擇哪種 SCD 類型，而是您的維度模型是否能讓業務準確回答其問題。當歷史報表反映實際歷史狀態，當當前報表顯示當前狀態，並且兩者之間的區別清晰且有意時，無論採用哪種特定類型，SCD 實作都是成功的。

隨著資料倉儲的演變和業務需求的變化，SCD 策略可能需要調整。在類型之間遷移的靈活性、記錄決策的紀律，以及在可能時選擇簡單性而非複雜性的智慧，比任何特定的技術選擇更能決定長期成功。
