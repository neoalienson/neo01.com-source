---
title: Connected 4 in 3D 提示詞
layout: tools
lang: zh-TW
---

# Connected 4 in 3D：技術方法與遊戲邏輯

本文件概述了為網頁瀏覽器建構 3D Connected 4 遊戲的概念方法，專注於使用 JavaScript 和 Three.js 進行渲染的純網頁實作。

## 第一部分：技術方法（純網頁與 Three.js）

該遊戲將是使用 HTML、CSS 和 JavaScript 建構的單頁網頁應用程式。Three.js 將用於所有 3D 渲染。

**建議架構：**

1.  **HTML 結構 (`index.html`)：**
    *   將包含用於 Three.js 渲染的 canvas 元素。
    *   將包含遊戲狀態和控制項的基本 UI 元素（例如重置按鈕）。

2.  **樣式 (`style.css`)：**
    *   將為 HTML 元素和 canvas 提供基本樣式。

3.  **遊戲邏輯和 3D 渲染 (`script.js`)：**
    *   這個單一 JavaScript 檔案將封裝核心遊戲邏輯和 Three.js 渲染。
    *   **Three.js 設定：** 初始化 3D 場景、相機和 WebGL 渲染器。
    *   **3D 棋盤和棋子：** 使用 Three.js 幾何體視覺化建立 5x5x5 網格（例如，棋盤孔使用圓柱體，棋子使用球體）。
    *   **使用者互動：** 實作滑鼠事件監聽器和 Three.js 光線投射以偵測使用者在 3D 棋盤上的點擊，將螢幕座標轉換為 3D 網格位置。
    *   **遊戲狀態視覺化：** 更新 3D 場景以反映當前遊戲狀態（例如，新增新棋子、清除棋盤）。

**工作流程範例：**

1.  **網頁載入：** `index.html` 載入，`style.css` 套用樣式，`script.js` 執行。
2.  **Three.js 場景初始化：** `script.js` 設定 Three.js 場景，渲染空的 3D 網格，並設定事件監聽器。
3.  **使用者點擊 3D 棋盤：** 偵測到滑鼠點擊事件。
4.  **光線投射：** Three.js 從點擊位置執行光線投射到 3D 場景中，以確定目標網格單元格 (x, z)。
5.  **遊戲邏輯處理：** JavaScript 遊戲邏輯接收 (x, z) 座標，確定棋子的 `y`（垂直）位置，更新其內部棋盤狀態，並檢查勝利/平局條件。
6.  **3D 場景更新：** JavaScript 程式碼指示 Three.js 在計算的 (x, y, z) 座標處新增新的 3D 棋子，並使用當前玩家的顏色。
7.  **遊戲狀態更新：** HTML UI 更新以反映當前遊戲狀態（例如，下一個玩家的回合、勝利/平局訊息）。

## 第二部分：核心遊戲邏輯（JavaScript）

3D Connected 4 的核心遊戲邏輯將在 JavaScript 中實作。此邏輯管理遊戲狀態、玩家回合、棋子放置規則和勝利/平局條件。

以下概述了核心遊戲邏輯的當前實作：

### 1. 遊戲棋盤表示

3D 遊戲棋盤表示為整數的三維陣列：

```javascript
let board; // 將初始化為 new Array(5).fill(0).map(() => new Array(5).fill(0).map(() => new Array(5).fill(0)));
```

*   `board[x][y][z]` 表示 5x5x5 立方體中的一個單元格。
*   `x`、`y`、`z` 範圍從 0 到 4。
*   `0`：表示空單元格。
*   `1`：表示玩家 1 放置的棋子（例如紅色）。
*   `2`：表示玩家 2 放置的棋子（例如黃色）。

### 2. 遊戲狀態管理

遊戲狀態由幾個變數管理：

*   `let currentPlayer = 1;`：追蹤輪到誰（1 或 2）。
*   `let gameOver = false;`：指示遊戲是否已結束（勝利或平局）。
*   `let gameStatus = "Player 1's Turn";`：顯示當前遊戲狀態的字串（例如「玩家 1 的回合」、「玩家 2 獲勝！」、「平局！」）。

### 3. 遊戲初始化 (`initializeGame()`)

此方法設定新遊戲：

*   將 `board` 重置為全零（空）。
*   將 `currentPlayer` 設回 1。
*   將 `gameOver` 設為 `false`。
*   將 `gameStatus` 更新為「玩家 1 的回合」。
*   清除 3D 場景中的所有現有棋子。

### 4. 棋子放置邏輯 (`addPiece(x, z)`)

此方法處理在遊戲中放置棋子：

*   **輸入：** 從使用者輸入取得 `x`（列）和 `z`（深度）座標。
*   **遊戲結束檢查：** 如果 `gameOver` 為 true，該方法立即返回。
*   **尋找最低可用 `y`：** 它從底部 (`y=0`) 向上迭代，以在所選列 (`x`, `z`) 中找到第一個空單元格 (`board[x][i][z] == 0`)。這模擬重力。
*   **放置棋子：** 如果找到空的 `y` 位置：
    *   在 `board[x][y][z]` 處使用 `currentPlayer` 的值更新 `board`。
    *   在計算的 (x, y, z) 座標處將新的 3D 棋子新增到 Three.js 場景中，並使用當前玩家的顏色。
*   **檢查勝利/平局條件：** 放置棋子後，它呼叫 `checkWin()` 和 `checkDraw()` 以確定下一個遊戲狀態。
*   **更新遊戲狀態：** 根據結果（勝利、平局或下一個玩家的回合）更新 `gameStatus`。
*   **切換玩家：** 如果遊戲未結束，`currentPlayer` 切換到另一個玩家。

### 5. 勝利條件檢查 (`checkWin(x, y, z)`)

這是遊戲邏輯中最複雜的部分。它檢查從新放置的棋子 `(x, y, z)` 開始，在 13 個可能的 3D 方向中的任何一個方向上是否有 4 個連續的 `currentPlayer` 顏色的棋子。

13 個方向是：

*   **3 個軸向方向：**
    *   X 軸：`(1, 0, 0)`
    *   Y 軸：`(0, 1, 0)`
    *   Z 軸：`(0, 0, 1)`
*   **6 個平面對角線方向：**
    *   XY 平面：`(1, 1, 0)`、`(1, -1, 0)`
    *   XZ 平面：`(1, 0, 1)`、`(1, 0, -1)`
    *   YZ 平面：`(0, 1, 1)`、`(0, 1, -1)`
*   **4 個空間對角線方向：**
    *   ` (1, 1, 1)`
    *   ` (1, 1, -1)`
    *   ` (1, -1, 1)`
    *   ` (1, -1, -1)`

`checkWin` 方法為每個方向呼叫 `checkLine`。

### 6. 線檢查 (`checkLine(x, y, z, dx, dy, dz)`)

此輔助方法從給定的 `(x, y, z)` 座標開始，檢查特定方向 (`dx`, `dy`, `dz`) 的勝利：

*   它沿著由起點和方向定義的線迭代，從起點檢查正負方向最多 4 個位置。
*   它計算 `currentPlayer` 顏色的連續棋子。
*   如果找到 4 個或更多連續棋子，它返回 `true`（勝利）。
*   它處理邊界條件（確保 `curX`、`curY`、`curZ` 保持在 0-4 範圍內）。

### 7. 平局條件檢查 (`checkDraw()`)

此方法確定遊戲是否為平局：

*   它迭代 `board` 上的每個單元格。
*   如果它找到任何空單元格 (`0`)，這意味著棋盤未滿，因此不是平局，返回 `false`。
*   如果所有單元格都已填滿（未找到 `0`），它返回 `true`（平局）。

此詳細大綱提供了對遊戲結構和邏輯的清晰理解，這將使用 JavaScript 和 Three.js 實作。
